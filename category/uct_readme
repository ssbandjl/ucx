总结:
1. 通过socket交换地址
2. 

API头文件: src/uct/api/uct.h
内存域资源描述符: typedef struct uct_md_resource_desc

接口属性(能力和限制), 嵌套结构体: struct uct_iface_attr

分散聚集IO, sgl, SGL, 聚散表: typedef struct uct_iov
stride: 1个内存跨度,范围, 所有 iov 列表中的长度总和必须小于或等于相应通信操作的 max_zcopy。 如果长度或计数为零，则不会访问 buffer 指向的内存。 否则，缓冲区必须指向有效的内存。 如果 count 为 1，则每个 iov 条目指定单个连续数据块 如果 count > 1，则每个 iov 条目指定 count 元素的跨步块以及连续元素之间的跨步字节距离


先执行一次: cd example; ./uct_hello_world


uct_example: uct_hello_world.c
启用编译: export HAVE_EXAMPLES=true
bash examples/uct_hello_world
server:  exec /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d ib17-0 -t tcp
gdb --args /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs


启动服务端: 主函数中解析命令行参数, 设置默认服务端口, 初始化上下文,
异步事件上下文: 管理定时器和FD通知
gdb: examples/uct_hello_world.c -> int main(int argc, char **argv)
  if (parse_cmd(argc, argv, &cmd_args)) -> int parse_cmd(int argc, char * const argv[], cmd_args_t *args)
    args->server_port   = 13337
  status = ucs_async_context_create(UCS_ASYNC_MODE_THREAD_SPINLOCK, &async) -> 创建异步执行上下文 分配并初始化异步执行上下文。 这可用于确保安全的事件传递, 模式为线程自旋锁
    async = ucs_malloc(sizeof(*async), "async context") -> 内部分配, 并记录内存分配信息
      void *ptr = malloc(size)
    status = ucs_async_context_init(async, mode)
      ucs_trace_func("async=%p", async) -> 跟踪方法
      status = ucs_mpmc_queue_init(&async->missed) -> 初始化多生产者/多消费者队列
      status = ucs_async_method_call(mode, context_init, async) -> .context_init       = ucs_async_poll_init -> 异步轮训初始化, 不阻塞
      async->last_wakeup = ucs_get_time() -> asm volatile("rdtsc" : "=a"(low), "=d"(high)) 汇编获取时间 -> UCS/ARCH/INFO：如果无法从CPU型号中读取x86 TSC值，请不要从/proc/cpuinfo中读取测量的CPU频率，因为它只能代表核心频率而不是TSC频率。 相反，通过一个短循环进行测量，当频率测量收敛或达到 1ms 时间限制时停止
  status = uct_worker_create(async, UCS_THREAD_MODE_SINGLE, &if_info.worker) -> 创建工人(独立资源) -> UCS_CLASS_DEFINE_NAMED_NEW_FUNC(uct_worker_create -> 用宏初始化工人(类似面向对象实例化) -> 创建一个工作对象。 工人代表着进步的引擎。 可以在应用程序中创建多个进度引擎，例如供多个线程使用。 Transports 可以为每个 Worker 分配单独的通信资源，以便每个 Worker 都可以独立于其他 Worker 进行操作 -> 声明/定义一个创建类实例的函数
  status = dev_tl_lookup(&cmd_args, &if_info) -> 查找期望的传输层, 动态加载, 由最小延迟决定要使用的设备和传输, 实参为地址指针, 形参为指针
    status = uct_query_components(&components, &num_components) -> 得到8个组件
      UCS_MODULE_FRAMEWORK_DECLARE(uct) -> 声明一个“框架”，它是可加载模块的特定集合的上下文。 通常特定框架中的模块提供相同内部接口的替代实现
      UCS_MODULE_FRAMEWORK_LOAD(uct, 0) -> void ucs_load_modules 加载所有模块, self, tcp, sysv, posix, ib, rdmacm, cma, knem, ...
        ucs_module_loader_init_paths -> 找到路径, 然后动态加载: ucs_module_load_one(framework, module_name, flags)
          void UCS_F_CTOR uct_ib_init()
            uct_component_register(&uct_ib_component)
            uct_tl_register(&uct_ib_component, uct_ib_tls[i]) -> 注册所有IB传输层
      ucs_list_for_each uct_components_list 8个组件 -> ucs_vfs_obj_add_dir -> ucs_vfs_node_add 虚拟文件系统
    component_attr.md_resources = alloca -> alloca - 分配自动释放的内存
    status = uct_component_query(components[cmpt_index], &component_attr)
      status = component->query_md_resources(component, &resources, &num_resources); -> uct_md_query_single_md_resource
    status = uct_md_config_read(components[cmpt_index], NULL, NULL, &md_config); -> 读取内存域资源
      status = uct_config_read(&bundle, &component->md_config, env_prefix)
        status = ucs_config_parser_fill_opts(config_bundle->data, entry, full_prefix, 0)
          ucs_config_parser_set_default_values(opts, entry->table) -> ucs_config_sscanf_table
          ucs_config_parser_get_sub_prefix(env_prefix, &sub_prefix)
          ucs_config_parse_config_files()
          ucs_config_apply_config_vars -> 应用环境变量, 以及自定义前缀的环境变量
    uct_md_open -> 重要函数, 打开内存域
      status = component->md_open(component, md_name, config, &md) -> ucs_status_t uct_ib_md_open
        ib_device_list = ibv_get_device_list(&num_devices) -> 获取所有网卡列表, 获取设备列表
        ibv_fork_init
        status = uct_ib_ops[i]->ops->open(ib_device, md_config, &md) -> static ucs_status_t uct_ib_mlx5_devx_md_open
          ctx = uct_ib_mlx5_devx_open_device(ibv_device)
            ctx = mlx5dv_open_device(ibv_device, &dv_attr) -> verbs_open_device -> rdma-core
            ibv_create_cq(ctx, 1, NULL, NULL, 0)
            ibv_destroy_cq(cq)
            event_channel = mlx5dv_devx_create_event_channel
            mlx5dv_devx_destroy_event_channel(event_channel)
          md = ucs_derived_of(uct_ib_md_alloc(sizeof(*md), "ib_mlx5_devx_md", ctx)
          status = uct_ib_mlx5_check_uar(md)
            uct_ib_mlx5_devx_uar_init
              uct_ib_mlx5_devx_alloc_uar
                mlx5dv_devx_alloc_uar
            uct_ib_mlx5_devx_uar_cleanup
          uct_ib_mlx5_devx_mr_lru_init(md)
          status = uct_ib_device_query(dev, ibv_device)
            uct_ib_query_device
              ibv_get_device_name
              ret = ibv_query_device_ex(ctx, NULL, attr)
                ret = vctx->query_device_ex(context, input, attr, sizeof(*attr))
            ibv_query_port
            ucs_topo_resolve_sysfs_path ->  "/sys/devices/pci0000:15/0000:15:04.0/0000:17:00.0" -> PCI地址
            ucs_topo_get_sysfs_dev
            uct_ib_device_set_pci_id
            ucs_topo_get_pci_bw
              effective_bw = (p->bw_gbps * 1e9 / 8.0) * width * ((double)p->encoding / p->decoding) * link_utilization; -> 计算带宽
          ret = mlx5dv_devx_general_cmd -> ucs_status_t uct_ib_mlx5_devx_general_cmd

          status = uct_ib_mlx5_devx_query_lag(md, &lag_state)
          md->port_select_mode = uct_ib_mlx5_devx_query_port_select(md)
          uct_ib_mlx5_is_xgvmi_alias_supported
          uct_ib_mlx5_devx_check_odp
          uct_ib_mlx5_devx_general_cmd
          uct_ib_md_open_common -> ucs_status_t uct_ib_md_open_common
            uct_ib_device_init
              uct_ib_device_get_locality
              ucs_sys_fcntl_modfl
                oldfl = fcntl(fd, F_GETFL)
            uct_ib_md_check_dmabuf(md)                
              ibv_reg_dmabuf_mr
          uct_ib_mlx5_md_port_counter_set_id_init
          ucs_mpool_init
          uct_ib_mlx5_md_buf_alloc
          uct_ib_md_parse_relaxed_order
          uct_ib_mlx5_devx_init_flush_mr
            uct_ib_reg_mr
        ....
        static ucs_status_t uct_self_md_open
        uct_md_vfs_init(component, md, md_name)
    uct_config_release
    uct_md_query
      status = uct_md_attr_v2_init(md, &md_attr_v2) -> static ucs_status_t uct_self_md_query -> ucs_status_t uct_ib_md_query
      uct_md_attr_from_v2(md_attr, &md_attr_v2)
    uct_md_query_tl_resources
      uct_self_query_tl_devices | uct_dc_mlx5_query_tl_devices
        uct_ib_device_query_ports
          uct_ib_device_port_check
            uct_ib_device_port_attr
    status = init_iface(tl_resources[tl_index].dev_name,
      status = uct_md_iface_config_read(iface_p->md, tl_name, NULL, NULL, &config) -> 读取并填充配置
      status = uct_iface_open(iface_p->md, iface_p->worker, &params, config
        status = tl->iface_open -> static UCS_CLASS_DEFINE_NEW_FUNC(uct_rc_verbs_iface_t -> static UCS_CLASS_INIT_FUNC(uct_rc_verbs_iface_t
          uct_rc_am_hdr_fill(&self->am_inl_hdr.rc_hdr, 0)
          status = uct_iface_mpool_init -> 创建地址控制器和原子内存池
          uct_rc_verbs_iface_init_inl_wrs
          status = uct_rc_init_fc_thresh(&config->super, &self->super)
          status = uct_rc_iface_qp_create
          uct_ib_destroy_qp(qp)
      uct_iface_progress_enable(iface_p->iface -> uct_base_iface_progress_enable_cb -> uct_rc_verbs_iface_common_progress_enable
        uct_rc_verbs_iface_common_prepost_recvs(iface)
          uct_rc_verbs_iface_post_recv_common
            uct_rc_verbs_iface_post_recv_always
              uct_ib_iface_prepare_rx_wrs
                UCT_TL_IFACE_GET_RX_DESC(&iface->super, mp, desc, break) -> ucs_mpool_get_inline
                  ucs_mpool_get_grow
                    ucs_mpool_grow -> chunk_alloc -> uct_iface_mp_chunk_alloc
                      uct_iface_mem_alloc
                    ...
                    ibv_reg_mr_iova2
              ibv_post_srq_recv  
      uct_rc_verbs_iface_progress(search) -> 驱动接口运转
        ucs_callbackq_add_safe
      status = uct_iface_query(iface_p->iface, &iface_p->iface_attr) -> uct_rc_verbs_iface_query
        status = uct_rc_iface_query
          status = uct_ib_iface_query -> ucs_status_t uct_ib_iface_query
            static const uint8_t ib_port_widths[] = {[1] = 1, [2] = 4, [4] = 8, [8] = 12, [16] = 2};
            uct_base_iface_query(&iface->super, iface_attr)
            active_width = uct_ib_iface_port_attr(iface)->active_width
            case UCT_IB_SPEED_EDR -> 网卡速度
              iface_attr->latency.c = 600e-9
              signal_rate           = 25.78125e9
              encoding              = 64.0/66.0
            num_path   = uct_ib_iface_is_roce(iface) 
          uct_ib_device_has_pci_atomics(dev))
        iface_attr->latency.m += 1e-9 -> 1ns 纳秒
        iface_attr->overhead   = 75e-9
        iface_attr->ep_addr_len = uct_ib_md_is_flush_rkey_valid
  connect_common
    ret = getaddrinfo(server, service, &hints, &res)
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol)
    setsockopt
    bind, listen, accept -> 等待客户端发起socket连接
  status = uct_iface_get_device_address(if_info.iface, own_dev)
  sendrecv(oob_sock, own_dev, if_info.iface_attr.device_addr_len, (void**)&peer_dev) -> 先通过socket发送和接收长度, 然后发送和接收地址, 交换地址
  uct_iface_is_reachable 检查地址是否可达 -> uct_ib_iface_is_reachable_v2 -> static int uct_ib_iface_dev_addr_is_reachable -> ucs_test_all_flags
    device_addr = (const uct_ib_address_t*) UCS_PARAM_VALUE -> 如果设置了字段掩码中的标志，则有条件地返回参数值。 否则，返回默认值
  status = uct_ep_create(&ep_params, &ep) -> 创建新端点 -> UCS_CLASS_DEFINE_NEW_FUNC
  ucs_vfs_obj_set_dirty(params->iface, uct_iface_vfs_refresh)
    ucs_vfs_global_init() -> UCS_INIT_ONCE(&ucs_vfs_init_once) 单例
    ucs_vfs_node_find_by_obj -> ucs_vfs_kh_find -> klib -> kh_get -> 独立且轻量级c库: https://github.com/attractivechaos/klib
  ucs_status_t uct_rc_verbs_ep_get_address
  status = uct_ep_connect_to_ep(ep, peer_dev, peer_ep) -> uct_rc_verbs_ep_connect_to_ep_v2
    status = uct_rc_iface_qp_connect(iface, ep->qp, qp_num, &ah_attr, path_mtu) -> ucs_status_t uct_rc_iface_qp_connect
      qp_attr.qp_state              = IBV_QPS_RTR -> 设备qp
      ret = ibv_modify_qp(qp, &qp_attr, qp_attr_mask); -> 设置qp状态机
      ...
      qp_attr.qp_state              = IBV_QPS_RTS
      ret = ibv_modify_qp(qp, &qp_attr, qp_attr_mask)
      ucs_debug("connected rc qp 0x%x on " -> 打印debug日志 -> connected rc qp 0x1a91b on mlx5_0:1/RoCE to lid 49152(+0) sl 0 remote_qp 0x1a91a mtu 1024 timer 18x7 rnr 13x7 rd_atom 16
  uct_worker_progress(if_info.worker) -> UCT 工作人员的显着进展。 该例程显式地处理任何未完成的通信操作和活动消息请求 -> uct_rc_verbs_iface_progress
    count = uct_rc_verbs_iface_poll_rx_common(iface) -> ibv_poll_cq
      uct_rc_verbs_iface_post_recv_common(iface, 0)
    return count + uct_rc_verbs_iface_poll_tx(iface) -> always_inline
      UCT_RC_VERBS_IFACE_FOREACH_TXWQE(&iface->super, i, wc, num_wcs) -> 遍历宏
      uct_rc_txqp_completion_desc
      ucs_arbiter_group_schedule -> 安排一个小组进行仲裁。 如果该组已经存在，则该操作将无效
      uct_rc_verbs_update_tx_res(&iface->super, ep, count)
        uct_rc_txqp_available_add
        uct_rc_iface_update_reads -> 将 RDMA_READ 积分释放回 RC iface。 RDMA_READ 积分在完成回调中释放，但不会释放到 RC iface 以避免 OOO 发送。 否则，如果读取信用是唯一缺少的资源并在完成回调中释放，则即使挂起队列不为空，下一个完成回调也将能够发送
        uct_rc_iface_add_cq_credits -> UCT/IB：修复错误处理后清除待处理请求的问题
      ucs_arbiter_dispatch(&iface->super.tx.arbiter, 1, uct_rc_ep_process_pending, NULL) -> 在仲裁器中调度工作元素。 对于每个组，只要回调返回 REMOVE_ELEM 或 NEXT_GROUP，最多会调度 per_group 工作元素。 然后，对下一组执行相同的操作，直到仲裁器变空或回调返回 STOP。 如果一个组没有元素，或其回调返回 REMOVE_GROUP，则它将被删除，直到使用 ucs_arbiter_group_schedule() 将其放回到仲裁器上
  if (barrier(oob_sock, progress_worker, if_info.worker)) -> TCP/TEST：修复 ucp_hello_world 同时 ep close 的问题
  out_free_ep -> 释放资源
  ...




      




  



client:
...
if (connect(sockfd, t->ai_addr, t->ai_addrlen) == 0)





      







typedef struct ucs_mpmc_queue, 多生产者多消费者线程安全队列。 在“良好”场景中，每次推/拉都是一个原子操作

typedef struct uct_tl_resource_desc, 通信资源描述符。 资源描述符是表示网络资源的对象。 资源描述符可以表示独立的通信资源（例如HCA端口、网络接口）或多个资源（例如多个网络接口或通信端口）。 它还可以表示通过单个物理网络接口定义的虚拟通信资源

md_resources, 内存域资源数组。 使用时，应在使用指向数组的指针调用 @ref uct_component_query 之前对其进行初始化，该数组足够大以容纳所有内存域资源条目。 调用后，该数组将填充现有内存域资源的信息。 为了分配该数组，您可以调用@ref uct_component_query两次：第一次将仅通过在field_mask中指定@ref UCT_COMPONENT_ATTR_FIELD_MD_RESOURCE_COUNT来获取所需的条目数量。 然后，可以为数组分配返回的条目数，并传递给对 @ref uct_component_query 的第二次调用，这次将 field_mask 设置为 @ref UCT_COMPONENT_ATTR_FIELD_MD_RESOURCES



connect_common
uct_iface_get_device_address
sendrecv
status = uct_ep_create(&ep_params, &ep)
uct_rc_verbs_ep_connect_to_ep_v2




client:
[root@node63 ucx]# /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs -n 172.17.29.63

main
ucs_status_t do_am_short
  UCT_INLINE_API ucs_status_t uct_ep_am_short
    ucs_status_t uct_rc_verbs_ep_am_short
      uct_rc_verbs_iface_fill_inl_am_sge
      uct_rc_verbs_ep_post_send
        ibv_post_send



(gdb) b ibv_create_qp
#0  0x00007ffff65347b0 in ibv_create_qp () from /lib64/libibverbs.so.1
#1  0x00007ffff6778a58 in uct_rc_verbs_can_create_qp (ctx=<optimized out>, pd=0x60d3f0) at rc/verbs/rc_verbs_iface.c:556
#2  0x00007ffff6778c23 in uct_rc_verbs_query_tl_devices (md=0x60efd0, tl_devices_p=0x7fffffffd630, num_tl_devices_p=0x7fffffffd620) at rc/verbs/rc_verbs_iface.c:581
#3  0x00007ffff792864f in uct_md_query_tl_resources (md=0x60efd0, resources_p=resources_p@entry=0x7fffffffd7b0, num_resources_p=num_resources_p@entry=0x7fffffffd790) at base/uct_md.c:94
#4  0x000000000040248c in dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:363
#5  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611
(gdb) c
(gdb) bt
#0  0x00007ffff65347b0 in ibv_create_qp () from /lib64/libibverbs.so.1
#1  0x00007ffff675db21 in ibv_create_qp_ex (qp_init_attr_ex=0x7fffffffd558, context=<optimized out>) at /usr/include/infiniband/verbs.h:3016
#2  uct_ib_iface_create_qp (iface=iface@entry=0x6160f0, attr=attr@entry=0x7fffffffd520, qp_p=qp_p@entry=0x7fffffffd4e0) at base/ib_iface.c:1024
#3  0x00007ffff677238b in uct_rc_iface_qp_create (iface=iface@entry=0x6160f0, qp_p=qp_p@entry=0x7fffffffd4e0, attr=attr@entry=0x7fffffffd520, max_send_wr=<optimized out>, srq=<optimized out>)
    at rc/base/rc_iface.c:838
#4  0x00007ffff67794ed in uct_rc_verbs_iface_t_init (tl_config=0x60e130, params=<optimized out>, worker=<optimized out>, tl_md=<optimized out>, _init_count=0x7fffffffd4d0, 
    _myclass=0x7ffff69fc760 <uct_rc_verbs_iface_t_class>, self=0x6160f0) at rc/verbs/rc_verbs_iface.c:357
#5  uct_rc_verbs_iface_t_new (arg0=<optimized out>, arg1=<optimized out>, arg2=<optimized out>, arg3=0x60e130, obj_p=0x7fffffffdcd8) at rc/verbs/rc_verbs_iface.c:461
#6  0x00007ffff7928b5b in uct_iface_open (md=0x60efd0, worker=0x607560, params=params@entry=0x7fffffffd820, config=0x60e130, iface_p=iface_p@entry=0x7fffffffdcd8) at base/uct_md.c:250
#7  0x0000000000402738 in init_iface (iface_p=0x7fffffffdac0, func_am_type=FUNC_AM_SHORT, tl_name=0x616010 "rc_verbs", dev_name=0x61601a "mlx5_0:1") at uct_hello_world.c:271
#8  dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:383
#9  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611


利用宏, 注册传输层:
UCT_TL_DEFINE_ENTRY(&uct_ib_component, rc_verbs, uct_rc_verbs_query_tl_devices,
                    uct_rc_verbs_iface_t, "RC_VERBS_",
                    uct_rc_verbs_iface_config_table,
                    uct_rc_verbs_iface_config_t);

UCT_TL_DEFINE_ENTRY(&uct_tcp_component, tcp, uct_tcp_query_devices,


已注册的传输层类型, 搜索关键字(UCT_TL_DEFINE_ENTRY)
uct_tl_t uct_rc_verbs_tl = { .name = "rc_verbs", .query_devices = uct_rc_verbs_query_tl_devices, .iface_open = uct_rc_verbs_iface_t_new, .config = { .name = "rc_verbs"" transport", .prefix = "RC_VERBS_", .table = uct_rc_verbs_iface_config_table, .size = sizeof(uct_rc_verbs_iface_config_t), } };


rc_verbs
ud_mlx5
ud_verbs
cma
knem
self
tcp



网卡,传输层操作, uct_rc_verbs_iface_tl_ops


创建完成队列:
#0  0x00007ffff65345c0 in ibv_create_cq () from /lib64/libibverbs.so.1
#1  0x00007ffff67694dc in uct_ib_mlx5_devx_open_device (ibv_device=ibv_device@entry=0x60de40) at mlx5/dv/ib_mlx5dv_md.c:947
#2  0x00007ffff676cfd8 in uct_ib_mlx5_devx_md_open (ibv_device=0x60de40, md_config=0x607750, p_md=0x7fffffffd5e0) at mlx5/dv/ib_mlx5dv_md.c:1111
#3  0x00007ffff6760d04 in uct_ib_md_open (component=<optimized out>, md_name=0x7fffffffd680 "mlx5_0", uct_md_config=0x607750, md_p=0x7fffffffd640) at base/ib_md.c:1051
#4  0x00007ffff792852d in uct_md_open (component=0x7ffff69faf40 <uct_ib_component>, md_name=0x7fffffffd680 "mlx5_0", config=<optimized out>, md_p=md_p@entry=0x7fffffffddc0) at base/uct_md.c:61
#5  0x0000000000402427 in dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:352
#6  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611

#0  0x00007ffff65345c0 in ibv_create_cq () from /lib64/libibverbs.so.1
#1  0x00007ffff6778a39 in uct_rc_verbs_can_create_qp (ctx=<optimized out>, pd=0x60d3f0) at rc/verbs/rc_verbs_iface.c:546
#2  0x00007ffff6778c23 in uct_rc_verbs_query_tl_devices (md=0x60efd0, tl_devices_p=0x7fffffffd630, num_tl_devices_p=0x7fffffffd620) at rc/verbs/rc_verbs_iface.c:581
#3  0x00007ffff792864f in uct_md_query_tl_resources (md=0x60efd0, resources_p=resources_p@entry=0x7fffffffd7b0, num_resources_p=num_resources_p@entry=0x7fffffffd790) at base/uct_md.c:94
#4  0x000000000040248c in dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:363
#5  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611

#0  0x00007ffff65347b0 in ibv_create_qp () from /lib64/libibverbs.so.1
#1  0x00007ffff675db21 in ibv_create_qp_ex (qp_init_attr_ex=0x7fffffffd558, context=<optimized out>) at /usr/include/infiniband/verbs.h:3016
#2  uct_ib_iface_create_qp (iface=iface@entry=0x6160f0, attr=attr@entry=0x7fffffffd520, qp_p=qp_p@entry=0x7fffffffd4e0) at base/ib_iface.c:1024
#3  0x00007ffff677238b in uct_rc_iface_qp_create (iface=iface@entry=0x6160f0, qp_p=qp_p@entry=0x7fffffffd4e0, attr=attr@entry=0x7fffffffd520, max_send_wr=<optimized out>, srq=<optimized out>)
    at rc/base/rc_iface.c:838
#4  0x00007ffff67794ed in uct_rc_verbs_iface_t_init (tl_config=0x60e130, params=<optimized out>, worker=<optimized out>, tl_md=<optimized out>, _init_count=0x7fffffffd4d0, 
    _myclass=0x7ffff69fc760 <uct_rc_verbs_iface_t_class>, self=0x6160f0) at rc/verbs/rc_verbs_iface.c:357
#5  uct_rc_verbs_iface_t_new (arg0=<optimized out>, arg1=<optimized out>, arg2=<optimized out>, arg3=0x60e130, obj_p=0x7fffffffdcd8) at rc/verbs/rc_verbs_iface.c:461
#6  0x00007ffff7928b5b in uct_iface_open (md=0x60efd0, worker=0x607560, params=params@entry=0x7fffffffd820, config=0x60e130, iface_p=iface_p@entry=0x7fffffffdcd8) at base/uct_md.c:250
#7  0x0000000000402738 in init_iface (iface_p=0x7fffffffdac0, func_am_type=FUNC_AM_SHORT, tl_name=0x616010 "rc_verbs", dev_name=0x61601a "mlx5_0:1") at uct_hello_world.c:271
#8  dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:383
#9  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611


help, 帮助, 选项, 参数:
[root@node63 ucx]# /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -h
Usage: uct_hello_world [parameters]
UCT hello world client/server example utility

Parameters are:
  -i      Select "uct_ep_am_short" function to send the message (default) // 默认短消息
  -b      Select "uct_ep_am_bcopy" function to send the message // 缓冲区
  -z      Select "uct_ep_am_zcopy" function to send the message // 零拷贝
  -d        Select device name
  -t        Select transport layer
  -n <name> Set node name or IP address of the server (required for client and should be ignored for server)
  -p <port>     Set alternative server port (default:13337)
  -6            Use IPv6 address in data exchange
  -s <size>     Set test string length (default:16)
  -m <mem type> Memory type of messages
                host - system memory (default)
                cuda - NVIDIA GPU memory
                cuda-managed - NVIDIA GPU managed/unified memory

Example:
  Server: uct_hello_world -d eth0 -t tcp
  /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs

  Client: uct_hello_world -d eth0 -t tcp -n localhost
  /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs -n 172.17.29.63


typedef struct uct_iface_ops 传输接口操作，API 中公开的每个操作都必须出现在下表中，以允许使用自定义操作创建接口/端点
ep_fence, 端点栅栏, 

typedef struct uct_worker, 进程引擎和用于分配通信资源的域。 不同工人独立驱动


ucs_status_t uct_ep_create, 创建新端点。 以可用模式之一创建 UCT 端点： -# 未连接端点：如果 uct_ep_params 中不存在任何地址，则会创建一个未连接端点。 要建立到远程端点的连接，需要调用 uct_ep_connect_to_ep  使用此模式需要 uct_ep_params_t::iface 具有 UCT_IFACE_FLAG_CONNECT_TO_EP 功能标志。 可以通过 uct_iface_query 获取。 -# 连接到远程接口：如果设置了 uct_ep_params_t::dev_addr 和 uct_ep_params_t::iface_addr，这将建立一个连接到远程接口的端点。 这要求 uct_ep_params_t::iface 具有 UCT_IFACE_FLAG_CONNECT_TO_IFACE 功能标志。 可以通过uct_iface_query获取。 -# 连接到远程套接字地址：如果设置了 uct_ep_params_t::sockaddr，这将创建一个连接到远程套接字的端点。 这要求设置 uct_ep_params::cm 或 uct_ep_params::iface。 在后一种情况下，接口必须支持 UCT_IFACE_FLAG_CONNECT_TO_SOCKADDR 标志，可以通过调用 uct_iface_query 来检查该标志。

参数：
[in] – params 用户为 ep_p 定义的 uct_ep_params_t 配置。
[out] – ep_p 填充新端点的句柄。

返回：
UCS_OK 端点创建成功。 这并不能保证端点已连接到参数中定义的目的地； 如果失败，错误将报告给通过 uct_iface_params_t.err_handler 提供给 uct_iface_open 的接口错误处理回调。 ucs_status_t 定义的错误代码


ucs_async_thread_add_event_fd
status = ucs_async_thread_start(&thread)
ucs_pthread_create(&thread->thread_id, ucs_async_thread_func




flow:
接口(uct_iface) -----> 操作(uct_iface_ops_t)
端点(uct_ep_h) 中包含 iface_操作




conjunction 连接
typedef struct uct_ib_address IB网络地址

UCS_CLASS_DEFINE_NEW_FUNC(uct_rc_verbs_ep_t, uct_ep_t, const uct_ep_params_t *); 宏展开
ucs_status_t uct_rc_verbs_ep_t_new(const uct_ep_params_t * arg0,  uct_ep_t **obj_p) 
{ 
  ucs_status_t status; 
  *obj_p = ((void *)0); 
  status = ({ ucs_class_t *cls = &uct_rc_verbs_ep_t_class; ucs_status_t _status; void *obj; obj = ucs_class_malloc(cls); 
  if (obj != ((void *)0)) 
  { 
    _status = ({ ucs_class_t *_cls = &uct_rc_verbs_ep_t_class; 
    int _init_counter = 1; 
    ucs_status_t __status; 
    __status = uct_rc_verbs_ep_t_init((uct_rc_verbs_ep_t*)(obj), _cls, &_init_counter,arg0); 
    if (__status != UCS_OK) { 
      ucs_class_call_cleanup_chain(&uct_rc_verbs_ep_t_class, (obj), _init_counter); 
    } (__status); }); 
    if (_status == UCS_OK) { *(obj_p) = (__typeof__(*(obj_p)))obj; } else { ucs_class_free(obj); *(obj_p) = ((void *)0); } } else { _status = UCS_ERR_NO_MEMORY; *(obj_p) = ((void *)0); } (_status); }); ucs_class_check_new_func_result(status, *obj_p); return status; }


数据结构: src/ucs/datastruct


日志级别: 
ucs_global_opts_table
export UCX_LOG_LEVEL=debug

ucs_init
  ucs_global_opts_init
    status = ucs_config_parser_fill_opts(&ucs_global_opts, UCS_CONFIG_GET_TABLE(ucs_global_opts_read_only_table), UCS_DEFAULT_ENV_PREFIX, 1); -> 配置文件 , 全局只读配置表 -> static ucs_config_field_t ucs_global_opts_read_only_table[] 
    static ucs_config_field_t ucs_global_opts_table[] -> 全局选项表
      ucs_config_parse_config_file
        file = fopen(file_path, "r"); -> 读取配置文件
        "/home/xb/project/ucx/install-debug/etc/ucx" -> 优先查找路径
    ucs_vfs_obj_add_dir(NULL, &ucs_global_opts, "ucs/global_opts")
    ucs_vfs_obj_add_rw_file(&ucs_global_opts, ucs_vfs_read_log_level, ucs_vfs_write_log_level, NULL, 0, "log_level")


io示例: buildlib/pr/io_demo/az-stage-io-demo.yaml



uct_rc_verbs_iface_common_progress_enable


typedef struct uct_rc_verbs_txcnt {
    uint16_t       pi;      /* producer (post_send) count */  生产者提交计数
    uint16_t       ci;      /* consumer (ibv_poll_cq) completion count */ 消费者完成计数
} uct_rc_verbs_txcnt_t;


仲裁者:
/*
 *  A mechanism to arbitrate among groups of queued work elements, which attempts
 * to be "fair" with respect to the groups.
 *
 * - "Arbiter" - the top-level entity.
 * - "Element" - a single work element.
 * - "Group"   - queue of work elements which would be dispatched in-order
 *
 * The arbiter contains a double-linked list of the group head elements. The
 * next group head to be dispatched is the first entry in the list. Whenever a
 * group is rescheduled, it's moved to the tail of the list. At any point, a
 * group head can be removed from the "middle" of the list.
 *
 * The groups and elements are arranged like this:
 *  - every arbitrated element points to the group (head).
 *  - first element in the group points to previous and next group (list)
 *  - first element in the group points to the first element of next group (next_group).
 *  - all except last element point to the next element in same group, and the
 *    last one points to the first (next).
 *
 * Note:
 *  Every element holds 4 pointers. It could be done with 3 pointers, so that
 *  the pointer to the previous group is put instead of "next" pointer in the last
 *  element in the group, when it is put on the arbiter queue. However, it makes
 *  the code much more complicated.
 *
 *
 * Arbiter:
 *   +=============+
 *   | list        +
 *   +======+======+
 *   | next | prev |
 *   +==|===+===|==+
 *      |       +----------------------------------------------+
 *      |                                                      |
 *      +------+                                               |
 *             |                                               |
 *             |                                               |
 * Elements:   V                                               V
 *       +------------+          +------------+          +------------+
 *       | list       |<-------->| list       |<-------->| list       |
 *       +------------+          +------------+          +------------+
 *    +->| next       +---+   +->| next       +---+      + next       +
 *    |  +------------+   |   |  +------------+   |      +------------+
 *    |  | group      |   |   |  | group      |   |      | group      |
 *    |  +------------+   |   |  +------------+   |      +--------+---+
 *    |                   |   |                   |          ^    |
 *    |                   |   |                   |          |    |
 *    |  +------------+   |   |  +------------+   |          |    |
 *    |  | list       |<--+   |  | list       |<--+          |    |
 *    |  +------------+       |  +------------+              |    |
 *    +--+ next       +       +--+ next       |              |    |
 *       +------------+          +------------+              |    |
 *       | group      |          | group      |              |    |
 *       +---------+--+          +--------+---+              |    |
 *            ^    |                 ^    |                  |    |
 * Groups:    |    |                 |    |                  |    |
 *            |    |                 |    |                  |    |
 *     +------+    |          +------+    |           +------+    |
 *     | tail |<---+          | tail |<---+           | tail |<---+
 *     +------+               +------+                +------+
 *
 */

typedef struct ucs_arbiter        ucs_arbiter_t;

一种在排队的工作元素组之间进行仲裁的机制，它试图对组进行“公平”
- “仲裁者” - 顶级实体。
- “元素”   - 单个工作元素。
-“组”      -将按顺序分派的工作元素队列，仲裁器包含组头元素的双链表。 下一个要分派的组头是列表中的第一个条目。 每当重新安排一个组时，它就会移至列表的末尾。 在任何时候，都可以从列表的“中间”删除组头。
组和元素的排列如下：
  - 每个仲裁元素都指向该组（头）。
  - 组中的第一个元素指向上一个和下一个组（列表）
  - 组中的第一个元素指向下一个组 (next_group) 的第一个元素。
  - 除最后一个元素外的所有元素都指向同一组中的下一个元素，最后一个元素指向第一个（下一个）。
注意：每个元素有4个指针。 可以使用 3 个指针来完成，以便当将其放入仲裁器队列时，将指向前一组的指针而不是组中最后一个元素中的“下一个”指针放入。 但是，这使得代码变得更加复杂





数据结构, data_struct
ucs_async_context


创建工人的宏展开: 声明/定义一个创建类实例的函数
ucs_status_t uct_worker_create(ucs_async_context_t* arg0, ucs_thread_mode_t arg1,  uct_worker_t **obj_p) { 
  ucs_status_t status; 
  *obj_p = ((void *)0); 
  status = ({ ucs_class_t *cls = &uct_priv_worker_t_class; ucs_status_t _status; void *obj; obj = ucs_class_malloc(cls); 
  if (obj != ((void *)0)) { 
    _status = ({ ucs_class_t *_cls = &uct_priv_worker_t_class; int _init_counter = 1;
    ucs_status_t __status; 
    __status = uct_priv_worker_t_init((uct_priv_worker_t*)(obj), _cls, &_init_counter,arg0 , arg1); 
    if (__status != UCS_OK) { 
      ucs_class_call_cleanup_chain(&uct_priv_worker_t_class, (obj), _init_counter);
    } 
    (__status); }); 
    if (_status == UCS_OK) { *(obj_p) = (__typeof__(*(obj_p)))obj; } else { ucs_class_free(obj); *(obj_p) = ((void *)0); } } else { _status = UCS_ERR_NO_MEMORY; *(obj_p) = ((void *)0); } (_status); }); ucs_class_check_new_func_result(status, *obj_p); return status; }




常用宏(预处理器): src/ucs/sys/preprocessor.h
/* Convert token to string */
#define UCS_PP_QUOTE(x)                   # x

/* Expand macro token to the macro value */
#define UCS_PP_EXPAND(x)                  x

/* Paste two expanded tokens */
#define __UCS_TOKENPASTE_HELPER(x, y)     x ## y
#define UCS_PP_TOKENPASTE(x, y)           __UCS_TOKENPASTE_HELPER(x, y)

/* Paste three expanded tokens */
#define __UCS_TOKENPASTE3_HELPER(x, y, z) x ## y ## z
#define UCS_PP_TOKENPASTE3(x, y, z)       __UCS_TOKENPASTE3_HELPER(x, y, z)

/* Unique value generator */
#ifdef __COUNTER__
#  define UCS_PP_UNIQUE_ID __COUNTER__
#else
#  define UCS_PP_UNIQUE_ID __LINE__
#endif

/* Creating unique identifiers, used for macros */
#define UCS_PP_APPEND_UNIQUE_ID(x)        UCS_PP_TOKENPASTE(x, UCS_PP_UNIQUE_ID)

/* Convert to string */
#define _UCS_PP_MAKE_STRING(x)            #x
#define UCS_PP_MAKE_STRING(x)             _UCS_PP_MAKE_STRING(x)




面向对象:
struct uct_rc_iface {
    uct_ib_iface_t              super;


/**
 * IB port active speed. IB端口速度
 */
enum {
    UCT_IB_SPEED_SDR     = 1,
    UCT_IB_SPEED_DDR     = 2,
    UCT_IB_SPEED_QDR     = 4,
    UCT_IB_SPEED_FDR10   = 8,
    UCT_IB_SPEED_FDR     = 16,
    UCT_IB_SPEED_EDR     = 32,
    UCT_IB_SPEED_HDR     = 64,
    UCT_IB_SPEED_NDR     = 128,
    UCT_IB_SPEED_LAST
};



注册tl, 传输层
_dl_init_internal
void UCS_F_CTOR uct_init()
uct_self_init() -> UCT_SINGLE_TL_INIT(&uct_self_component, self,,,)
   void uct_self_init(void) { {; uct_component_register(&uct_self_component);}; uct_tl_register(&uct_self_component, &uct_self_tl); }  
   void uct_self_cleanup(void) { uct_tl_unregister(&uct_self_tl); {uct_component_unregister(&uct_self_component); ;}; }
uct_tl_register
  ucs_list_add_tail(&component->tl_list, &tl->list)



所有IB传输层类型(tl):
static uct_tl_t *uct_ib_tls[] = {
#ifdef HAVE_TL_DC
    &UCT_TL_NAME(dc_mlx5),
#endif
#ifdef HAVE_TL_RC
    &UCT_TL_NAME(rc_verbs),
#endif
#if defined (HAVE_TL_RC) && defined (HAVE_MLX5_DV)
    &UCT_TL_NAME(rc_mlx5),
#endif
#ifdef HAVE_TL_UD
    &UCT_TL_NAME(ud_verbs),
#endif
#if defined (HAVE_TL_UD) && defined (HAVE_MLX5_HW_UD)
    &UCT_TL_NAME(ud_mlx5)
#endif
};


类: src/ucs/type/class.h


wireup, 连线


网络插件:
● ofi: Libfabric (OpenFabrics Interfaces)**
● portals4: Portals-based networks (uncommon)
● self: Process-loopback communications
● sm: Shared memory
● smcuda: CUDA-aware shared memory
● tcp: TCP
● uct: UCX**
● ugni: Cray uGNI (userspace Generic Network Interface)**
● usnic: Cisco usNIC (userspace NIC)



环境变量前缀与配置文件名:
#define UCS_DEFAULT_ENV_PREFIX "UCX_"
#define UCS_CONFIG_ARRAY_MAX   128
#define UCX_CONFIG_FILE_NAME   "ucx.conf"

全局选项配置:
ucs_global_opts_t ucs_global_opts = {
    .log_component         = {UCS_LOG_LEVEL_WARN, "UCX", "*"},
    .log_print_enable      = 0,
    .log_file              = "",
    .log_file_size         = SIZE_MAX,
    .log_file_rotate       = 0,
    .log_buffer_size       = 1024,
    .log_data_size         = 0,
    .mpool_fifo            = 0,
    .handle_errors         = UCS_BIT(UCS_HANDLE_ERROR_BACKTRACE),
    .error_signals         = { NULL, 0 },
    .error_mail_to         = "",
    .error_mail_footer     = "",
    .gdb_command           = "gdb",
    .debug_signo           = SIGHUP,
    .log_level_trigger     = UCS_LOG_LEVEL_FATAL,
    .warn_unused_env_vars  = 1,
    .enable_memtype_cache  = UCS_TRY,
    .async_signo           = SIGALRM,
    .stats_dest            = "",
    .tuning_path           = "",
    .memtrack_dest         = "",
    .memtrack_limit        = UCS_MEMUNITS_INF,
    .stats_trigger         = "exit",
    .profile_mode          = 0,
    .profile_file          = "",
    .stats_filter          = { NULL, 0 },
    .stats_format          = UCS_STATS_FULL,
    .topo_prio             = { NULL, 0 },
    .vfs_enable            = 1,
    .vfs_thread_affinity   = 0,
    .rcache_check_pfn      = 0,
    .module_dir            = UCX_MODULE_DIR, /* defined in Makefile.am */ 模块搜索路径
    .module_log_level      = UCS_LOG_LEVEL_TRACE,
    .modules               = { {NULL, 0}, UCS_CONFIG_ALLOW_LIST_ALLOW_ALL },
    .arch                  = UCS_ARCH_GLOBAL_OPTS_INITALIZER,
    .rcache_stat_min       = 0,
    .rcache_stat_max       = 0
};



类型定义头文件: src/uct/api/uct_def.h



struct uct_md_attr
Memory domain attributes
} uct_md_attr_v2_t;
内存域属性。 该结构定义了内存域的属性，其中包括可分配的最大内存、访问内存所需的凭据、指示 CPU 邻近度的 CPU 掩码以及指示可分配的内存类型 (CPU/CUDA/ROCM) 的位图。 检测到的、分配的、访问的以及可以返回 dmabuf 属性的内存类型



static ucs_status_t uct_ib_verbs_md_open
  uct_ib_device_query
    status = uct_ib_query_device(dev->ibv_context, &dev->dev_attr)
      ret = ibv_query_device(ctx, attr) -> 查询网卡信息




ibv_get_device_list



typedef struct {
    double     bw_gbps;       /* Link speed */ 双精度,浮点数
    uint16_t   payload;       /* Payload used to data transfer */
    uint16_t   tlp_overhead;  /* PHY + data link layer + header + CRC */
    uint16_t   ctrl_ratio;    /* Number of TLC before ACK */
    uint16_t   ctrl_overhead; /* Length of control TLP */
    uint16_t   encoding;      /* Number of encoded symbol bits */
    uint16_t   decoding;      /* Number of decoded symbol bits */
    const char *name;         /* Name of PCI generation */
} ucs_topo_pci_info_t;


传输层包封装
MSC8156 技术数据表 (MSC8156)。 详细介绍了信号、AC/DC 特性、时钟信号特性、封装和引脚排列以及电气设计...
https://www.nxp.com/products/processors-and-microcontrollers/additional-mpu-mcus-architectures/digital-signal-processors/high-performance-six-core-dsp:MSC8156
/*
 * - TLP (Transaction Layer Packet) overhead calculations (no ECRC):
 *   Gen1/2:
 *     Start   SeqNum   Hdr_64bit   LCRC   End
 *       1   +   2    +   16      +   4  +  1  = 24
 *
 *   Gen3/4:
 *     Start   SeqNum   Hdr_64bit   LCRC
 *       4   +   2    +   16      +   4  = 26
 *
 * - DLLP (Data Link Layer Packet) overhead calculations:
 *    - Control packet 8b ACK + 8b flow control
 *    - ACK/FC ratio: 1 per 4 TLPs
 *
 * References:
 * [1] https://www.xilinx.com/support/documentation/white_papers/wp350.pdf
 * [2] https://xdevs.com/doc/Standards/PCI/PCI_Express_Base_4.0_Rev0.3_February19-2014.pdf
 * [3] https://www.nxp.com/docs/en/application-note/AN3935.pdf
 */

MSC8156 基于采用 StarCore® 技术构建的业界最高性能 DSP 内核，专为当今无线宽带、医疗成像、航空航天、国防以及先进测试和测量市场的高性能应用的高级处理要求和功能而设计。 它提供更高的性能和节能，在高度集成的片上系统 (SoC) 中利用 45 nm 处理技术，提供相当于 6 GHz 单核设备的性能。 MSC8156 帮助设备制造商创建最终产品和服务，在更小的硬件占用空间中集成更多功能。

MSC8156 DSP 提供高水平的性能和集成度，结合了六个完全可编程的增强型 SC3850 DSP 内核，每个内核的运行速度高达 1 GHz。 MAPLE-B 加速器由 NXP® 开发并集成在片上，支持 Turbo 和 Viterbi 通道解码以及 DFT/iDFT 和 FFT/iFFT 算法的硬件加速。 基于 RISC 的高性能内部 QUICC Engine® 子系统支持多种网络协议，以保证数据包网络上的可靠数据传输，同时显着减轻 DSP 内核的处理负担。

MSC8156嵌入大容量内部存储器，支持多种先进的高速接口类型，包括两个RapidIO®接口、两个用于网络通信的千兆位以太网接口、一个PCI Express®控制器、两个用于高速、行业标准存储器接口的DDR控制器 和四个多通道TDM 接口。 MSC8156 通过与所有 MSC825x 和 MSC815x DSP 设备的引脚兼容性实现了高度的可扩展性。


接口能力:
iface_attr->cap.flags       = UCT_IFACE_FLAG_AM_BCOPY        |
                              UCT_IFACE_FLAG_AM_ZCOPY        |
                              UCT_IFACE_FLAG_PUT_BCOPY       |
                              UCT_IFACE_FLAG_PUT_ZCOPY       |
                              UCT_IFACE_FLAG_GET_BCOPY       |
                              UCT_IFACE_FLAG_GET_ZCOPY       |
                              UCT_IFACE_FLAG_PENDING         |
                              UCT_IFACE_FLAG_CONNECT_TO_EP   |
                              UCT_IFACE_FLAG_CB_SYNC;
iface_attr->cap.event_flags = UCT_IFACE_FLAG_EVENT_SEND_COMP |
                              UCT_IFACE_FLAG_EVENT_RECV      |
                              UCT_IFACE_FLAG_EVENT_FD;




三种数据发送模式(活动消息):
/* Send active message to remote endpoint */
if (cmd_args.func_am_type == FUNC_AM_SHORT) {
    status = do_am_short(&if_info, ep, id, &cmd_args, str);
} else if (cmd_args.func_am_type == FUNC_AM_BCOPY) {
    status = do_am_bcopy(&if_info, ep, id, &cmd_args, str);
} else if (cmd_args.func_am_type == FUNC_AM_ZCOPY) {
    status = do_am_zcopy(&if_info, ep, id, &cmd_args, str);
}

短消息, 缓存区, 零拷贝
case 'i':
    args->func_am_type = FUNC_AM_SHORT;
    break;
case 'b':
    args->func_am_type = FUNC_AM_BCOPY;
    break;
case 'z':
    args->func_am_type = FUNC_AM_ZCOPY;


火焰图:
cd /home/xb/fire/FlameGraph
perf record -e cpu-clock  --call-graph dwarf -p 512634

perf script -i perf.data &> perf.unfold
./stackcollapse-perf.pl ./perf.unfold &> ../perf.folded
./flamegraph.pl ../perf.folded > ../perf.svg
sz -y ../perf.svg 


do_am_bcopy
  uct_ep_am_bcopy
    uct_rc_verbs_ep_am_bcopy
      UCT_RC_IFACE_GET_TX_AM_BCOPY_DESC
      ucs_mpool_get_inline
      uct_rc_verbs_ep_post_send_desc
        uct_rc_verbs_ep_post_send
          uct_rc_iface_tx_moderation
          uct_rc_ep_fm
          uct_ib_log_post_send
          ibv_post_send
          uct_rc_verbs_txqp_posted
        uct_rc_txqp_add_send_op_sn


ucs_status_t do_am_zcopy
  uct_md_mem_reg -> UCS_PROFILE_CALL_ALWAYS(ibv_reg_mr -> 注册内存 -> 当 access_flags 包含 IBV_ACCESS_ON_DEMAND 时，ibv_reg_mr() 可能会失败并出现 EAGAIN。 这意味着预取由于与失效冲突而失败
    __ibv_reg_mr
  comp.uct_comp.func   = zcopy_completion_cb
  do ... while (status == UCS_ERR_NO_RESOURCE) -> 没资源时退出循环 
  status = uct_ep_am_zcopy -> ep->iface->ops.ep_am_zcopy
    ucs_status_t uct_rc_mlx5_ep_am_zcopy | uct_rc_verbs_ep_am_zcopy
      UCT_CHECK_IOV_SIZE
      status = uct_rc_mlx5_ep_zcopy_post(ep, MLX5_OPCODE_SEND, iov, iovcnt, 0ul, id, header, header_length, 0, 0, 0ul, 0, 0, MLX5_WQE_CTRL_SOLICITED, uct_rc_ep_send_op_completion_handler, 0, comp);
        uct_rc_mlx5_txqp_dptr_post_iov
          uct_rc_mlx5_am_hdr_fill
          uct_ib_mlx5_inline_copy
          uct_rc_mlx5_common_post_send
            uct_ib_mlx5_post_send
              uct_ib_mlx5_bf_copy
                uct_ib_mlx5_bf_copy_bb
            uct_rc_txqp_posted
        uct_rc_txqp_add_send_comp
  uct_worker_progress




io描述
typedef struct uct_iov {
    void     *buffer;   /**< Data buffer */
    size_t    length;   /**< Length of the payload in bytes */
    uct_mem_h memh;     /**< Local memory key descriptor for the data */
    size_t    stride;   /**< Stride between beginnings of payload elements in
                             the buffer in bytes */
    unsigned  count;    /**< Number of payload elements in the buffer */
} uct_iov_t;


内联文件:
noinst_HEADERS += \
	mlx5/ib_mlx5_log.h \
	mlx5/ib_mlx5.h \
	mlx5/ib_mlx5.inl \
	mlx5/dv/ib_mlx5_dv.h \
	mlx5/dv/ib_mlx5_ifc.h


extern "C" static inline ucs_status_t uct_ep_am_zcopy(uct_ep_h ep, uint8_t id, const void *header, unsigned int header_length, const uct_iov_t *iov, size_t iovcnt, unsigned int flags, uct_completion_t *comp)
发送活动消息，同时避免本地内存复制 ::uct_iov_t 结构的 iov 数组中的输入数据发送到远程端（“收集输出”）。 iov 中的缓冲区按数组顺序进行处理。 这意味着函数在继续执行 iov[1] 之前完成 iov[0]，依此类推

参数：
[in] – ep 目标端点句柄。
[in] – id 活动消息 ID。 必须在 0..UCT_AM_ID_MAX-1 范围内。
[in] – header 活动消息头。
[in] – header_length 活动消息头长度（以字节为单位）。
[in] – iov 指向 ::uct_iov_t 结构数组。 iov 指针必须是 ::uct_iov_t 结构数组的有效地址。 特定的结构指针必须是有效的地址。 不需要 NULL 终止的数组。
[in] – iovcnt iov data ::uct_iov_t 结构数组的大小。 如果 iovcnt 为零，则数据被视为空。 iovcnt 受 uct_iface_attr_cap_am_max_iov "uct_iface_attr::cap::am::max_iov" 限制。
[in] – flags 活动消息标志，请参阅 uct_msg_flags。
[in] – 由 ::uct_completion_t 定义的 comp 完成句柄。

返回：
UCS_OK 操作成功完成。 UCS_INPROGRESS 某些通信操作仍在进行中。 如果提供了非 NULL comp，它将在完成这些操作后更新。 UCS_ERR_NO_RESOURCE 由于缺少发送资源而无法启动操作

笔记：
如果操作返回 UCS_INPROGRESS，则在 comp 完成操作之前，不得修改 iov 数组指向的内存缓冲区。 标头可以被释放或更改


test, google, ut, 单元测试, uct, 
gtest_SOURCES
gtest_SOURCES = common/main.cc
test/gtest/uct


test/gtest/common/main.cc -> main
  InitGoogleTest
  watchdog_start
  set_log_level
  RUN_ALL_TESTS
  watchdog_stop
  analyze_test_results



static inline ucs_status_t uct_iface_flush(uct_iface_h iface, unsigned int flags, uct_completion_t *comp)
刷新接口上未完成的通信操作。 刷新此调用之前在接口上发出的所有未完成的通信。 操作在原点或目标处完成。 确切的完成语义取决于 flags 参数。

参数：
[in] – iface 用于刷新通信的接口。
[in] – flags 控制完成语义的标志（当前仅支持 UCT_FLUSH_FLAG_LOCAL）。
[inout] – comp 完成句柄，由 uct_completion_t 定义。 可以为 NULL，这意味着调用将返回接口的当前状态，并且在未完成通信的情况下不会生成完成。 如果它不为 NULL，则调用完成时完成计数器会减 1。 当计数器达到 0 时调用完成回调

返回：
UCS_OK - 没有剩余的未完成的通信。 UCS_INPROGRESS - 某些通信操作仍在进行中。 如果提供了非 NULL 'comp'，它将在完成这些操作后更新


同: uct_ep_am_zcopy
static inline ucs_status_t uct_ep_put_zcopy(uct_ep_h ep, const uct_iov_t *iov, size_t iovcnt, uint64_t remote_addr, uct_rkey_t rkey, uct_completion_t *comp)



