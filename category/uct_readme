总结:
1. 通过socket交换地址
2. 

API头文件: src/uct/api/uct.h
内存域资源描述符: typedef struct uct_md_resource_desc

接口属性(能力和限制), 嵌套结构体: struct uct_iface_attr

分散聚集IO, sgl, SGL, 聚散表: typedef struct uct_iov
stride: 1个内存跨度,范围, 所有 iov 列表中的长度总和必须小于或等于相应通信操作的 max_zcopy。 如果长度或计数为零，则不会访问 buffer 指向的内存。 否则，缓冲区必须指向有效的内存。 如果 count 为 1，则每个 iov 条目指定单个连续数据块 如果 count > 1，则每个 iov 条目指定 count 元素的跨步块以及连续元素之间的跨步字节距离


先执行一次: cd example; ./uct_hello_world


uct_example: uct_hello_world.c
启用编译: export HAVE_EXAMPLES=true
bash examples/uct_hello_world
server:  exec /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d ib17-0 -t tcp
gdb --args /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs


启动服务端: 主函数中解析命令行参数, 设置默认服务端口, 初始化上下文,
异步事件上下文: 管理定时器和FD通知
gdb: examples/uct_hello_world.c -> int main(int argc, char **argv)
  if (parse_cmd(argc, argv, &cmd_args)) -> int parse_cmd(int argc, char * const argv[], cmd_args_t *args)
    args->server_port   = 13337
  status = ucs_async_context_create(UCS_ASYNC_MODE_THREAD_SPINLOCK, &async) -> 创建异步执行上下文, 分配并初始化异步执行上下文。 这可用于确保安全的事件传递, 模式为线程自旋锁(可重入), 在异步对象上, 初始化多生产者和多消费者队列
    async = ucs_malloc(sizeof(*async), "async context") -> 内部分配, 并记录内存分配信息
      void *ptr = malloc(size)
    status = ucs_async_context_init(async, mode)
      ucs_trace_func("async=%p", async) -> 跟踪方法
      status = ucs_mpmc_queue_init(&async->missed) -> 初始化多生产者/多消费者队列
        ucs_queue_head_init(&mpmc->queue)
        pthread_spin_init(&lock->lock, lock_flags) -> 初始化自旋锁, 标志: PTHREAD_PROCESS_SHARED 或 PTHREAD_PROCESS_PRIVATE
      status = ucs_async_method_call(mode, context_init, async) -> .context_init       = ucs_async_poll_init -> 异步轮训初始化, 不阻塞
      async->last_wakeup = ucs_get_time() -> asm volatile("rdtsc" : "=a"(low), "=d"(high)) 汇编获取时间 -> UCS/ARCH/INFO：如果无法从CPU型号中读取x86 TSC值，请不要从/proc/cpuinfo中读取测量的CPU频率，因为它只能代表核心频率而不是TSC频率。 相反，通过一个短循环进行测量，当频率测量收敛或达到 1ms 时间限制时停止
        ucs_async_thread_spinlock_ops.context_init(async) -> ucs_async_thread_spinlock_init -> 可重入自旋锁上下文初始化
  status = uct_worker_create(async, UCS_THREAD_MODE_SINGLE, &if_info.worker) -> 创建工人(独立资源) -> UCS_CLASS_DEFINE_NAMED_NEW_FUNC(uct_worker_create -> 用宏初始化工人(类似面向对象实例化) -> 创建一个工作对象。 工人代表着progress的引擎。 可以在应用程序中创建多个进度引擎，例如供多个线程使用。 Transports 可以为每个 Worker 分配单独的通信资源，以便每个 Worker 都可以独立于其他 Worker 进行操作 -> 声明/定义一个创建类实例的函数, 初始化工人私有worker, 传输层链表
    ucs_class_t *cls = &uct_priv_worker_t_class -> typedef struct uct_priv_worker
    obj = ucs_class_malloc(cls)
    ucs_class_t *_cls = &uct_priv_worker_t_class
    uct_priv_worker_t_init -> static UCS_CLASS_INIT_FUNC(uct_priv_worker_t -> static UCS_CLASS_INIT_FUNC(uct_priv_worker_t -> 初始化父类以及当前类的传输链表
      static UCS_CLASS_INIT_FUNC(uct_worker_t)
        ucs_callbackq_init(&self->progress_q);
        ucs_vfs_obj_add_dir(NULL, self, "uct/worker/%p", self)
  status = dev_tl_lookup(&cmd_args, &if_info) -> 查找期望的传输层, 动态加载, 由最小延迟决定要使用的设备和传输, 实参为地址指针, 形参为指针
    status = uct_query_components(&components, &num_components) -> 查询组件列表。 获取当前系统上可用的传输组件列表, 得到8个组件
      UCS_MODULE_FRAMEWORK_DECLARE(uct) -> 声明一个“框架”，它是可加载模块的特定集合的上下文。 通常特定框架中的模块提供相同内部接口的替代实现
        static ucs_init_once_t ucs_framework_init_once_uct = { { { 0, 0, 0, 0, 0, 0, 0, { 0, 0 } } }, 0 } -> 互斥锁+初始化标记
      UCS_MODULE_FRAMEWORK_LOAD(uct, 0) -> void ucs_load_modules 加载所有模块, self, tcp, sysv, posix, ib, rdmacm, cma, knem, ...
      [in] – _flags 模块加载标志，参见 ucs_module_load_flags_t 框架中的模块由 dlopen() 加载。 模块的共享库名称为：“lib<framework>_<module>.so.<version>”，其中： - <framework> 是框架名称 - <module> 是模块名称。 框架中所有模块的列表由自动生成的 config.h 文件中的预处理器宏 <framework>_MODULES 定义，例如：#define foo_MODULES ":bar1:bar2"。 - <version> 是模块的共享库版本，由 libtool 生成。 它是从当前库 (libucs) 的完整路径中提取的。 在以下位置搜索模块共享库（按优先级顺序）： 1. 当前共享库 (libucs) 目录内的“ucx”子目录 2. ${libdir}/ucx，其中 ${libdir} 是 库的安装目录 请注意，如果 libucs 是从其安装路径加载的，则 (1) 和 (2) 是同一位置。 仅当 libucs 被移动或从构建目录运行时，路径才会不同，在这种情况下，优先使用“本地库”而不是“已安装的”库。[in] – _name 框架名称（作为令牌）
        ucs_load_modules("uct", uct_MODULES, &ucs_framework_init_once_uct, 0)
          ucs_module_loader_init_paths -> 找到路径, 然后动态加载: ucs_module_load_one(framework, module_name, flags) -> ucs_module_init(module_path, dl) -> 找到初始化方法名, 如: module_init_name 
          ucs_module_loader_add_dl_dir
            动态库路径: 0x6070b0 "/home/xb/project/ucx/src/ucs/.libs/libucs.so.0"
            dladdr((void*)&ucs_module_loader_state, &dl_info) -> 利用dladdr来获得so自身的路径(ucs_module_loader_state)
            ucs_module_loader_state.srch_path[ucs_module_loader_state.srchpath_cnt++] = path -> 记录动态库位置
          ucs_module_loader_add_install_dir

          ucs_module_global_init -> 查找动态库入库函数地址: addr = dlsym(dl, symbol) -> status = init_func()
            void UCS_F_CTOR uct_ib_init()
              uct_component_register(&uct_ib_component)
              uct_tl_register(&uct_ib_component, uct_ib_tls[i]) -> 注册所有IB传输层
      ucs_list_for_each uct_components_list 8个组件 -> ucs_vfs_obj_add_dir -> ucs_vfs_node_add 虚拟文件系统
    component_attr.md_resources = alloca -> alloca - 分配自动释放的内存
    status = uct_component_query(components[cmpt_index], &component_attr)
      status = component->query_md_resources(component, &resources, &num_resources); -> uct_md_query_single_md_resource
      UCS_MODULE_FRAMEWORK_LOAD(uct_ib, 0) -> 调用查询内存域资源接口中会加载对应的动态库
    status = uct_md_config_read(components[cmpt_index], NULL, NULL, &md_config); -> 读取内存域资源
      status = uct_config_read(&bundle, &component->md_config, env_prefix)
        status = ucs_config_parser_fill_opts(config_bundle->data, entry, full_prefix, 0)
          ucs_config_parser_set_default_values(opts, entry->table) -> ucs_config_sscanf_table
          ucs_config_parser_get_sub_prefix(env_prefix, &sub_prefix)
          ucs_config_parse_config_files()
          ucs_config_apply_config_vars -> 应用环境变量, 以及自定义前缀的环境变量
    uct_md_open -> 重要函数, 打开内存域
      status = component->md_open(component, md_name, config, &md) -> ucs_status_t uct_ib_md_open
        ib_device_list = ibv_get_device_list(&num_devices) -> 获取所有网卡列表, 获取设备列表
        ibv_fork_init
        status = uct_ib_ops[i]->ops->open(ib_device, md_config, &md) -> static ucs_status_t uct_ib_mlx5_devx_md_open
          ctx = uct_ib_mlx5_devx_open_device(ibv_device)
            ctx = mlx5dv_open_device(ibv_device, &dv_attr) -> verbs_open_device -> rdma-core
            ibv_create_cq(ctx, 1, NULL, NULL, 0)
            ibv_destroy_cq(cq)
            event_channel = mlx5dv_devx_create_event_channel
            mlx5dv_devx_destroy_event_channel(event_channel)
          md = ucs_derived_of(uct_ib_md_alloc(sizeof(*md), "ib_mlx5_devx_md", ctx)
          status = uct_ib_mlx5_check_uar(md)
            uct_ib_mlx5_devx_uar_init
              uct_ib_mlx5_devx_alloc_uar
                mlx5dv_devx_alloc_uar
            uct_ib_mlx5_devx_uar_cleanup
          uct_ib_mlx5_devx_mr_lru_init(md)
          status = uct_ib_device_query(dev, ibv_device)
            uct_ib_query_device
              ibv_get_device_name
              ret = ibv_query_device_ex(ctx, NULL, attr)
                ret = vctx->query_device_ex(context, input, attr, sizeof(*attr))
            ibv_query_port
            ucs_topo_resolve_sysfs_path ->  "/sys/devices/pci0000:15/0000:15:04.0/0000:17:00.0" -> PCI地址
            ucs_topo_get_sysfs_dev
            uct_ib_device_set_pci_id
            ucs_topo_get_pci_bw
              effective_bw = (p->bw_gbps * 1e9 / 8.0) * width * ((double)p->encoding / p->decoding) * link_utilization; -> 计算带宽
          ret = mlx5dv_devx_general_cmd -> ucs_status_t uct_ib_mlx5_devx_general_cmd

          status = uct_ib_mlx5_devx_query_lag(md, &lag_state)
          md->port_select_mode = uct_ib_mlx5_devx_query_port_select(md)
          uct_ib_mlx5_is_xgvmi_alias_supported
          uct_ib_mlx5_devx_check_odp
          uct_ib_mlx5_devx_general_cmd
          uct_ib_md_open_common -> ucs_status_t uct_ib_md_open_common
            uct_ib_device_init
              uct_ib_device_get_locality
              ucs_sys_fcntl_modfl
                oldfl = fcntl(fd, F_GETFL)
            uct_ib_md_check_dmabuf(md)                
              ibv_reg_dmabuf_mr
          uct_ib_mlx5_md_port_counter_set_id_init
          ucs_mpool_init
          uct_ib_mlx5_md_buf_alloc
          uct_ib_md_parse_relaxed_order
          uct_ib_mlx5_devx_init_flush_mr
            uct_ib_reg_mr
        ....
        static ucs_status_t uct_self_md_open
        uct_md_vfs_init(component, md, md_name)
    uct_config_release
    uct_md_query
      status = uct_md_attr_v2_init(md, &md_attr_v2) -> static ucs_status_t uct_self_md_query -> ucs_status_t uct_ib_md_query
      uct_md_attr_from_v2(md_attr, &md_attr_v2)
    uct_md_query_tl_resources
      uct_self_query_tl_devices | uct_dc_mlx5_query_tl_devices
        uct_ib_device_query_ports
          uct_ib_device_port_check
            uct_ib_device_port_attr
    status = init_iface(tl_resources[tl_index].dev_name,
      status = uct_md_iface_config_read(iface_p->md, tl_name, NULL, NULL, &config) -> 读取并填充配置
      status = uct_iface_open(iface_p->md, iface_p->worker, &params, config
        status = tl->iface_open -> static UCS_CLASS_DEFINE_NEW_FUNC(uct_rc_verbs_iface_t -> static UCS_CLASS_INIT_FUNC(uct_rc_verbs_iface_t
          uct_rc_am_hdr_fill(&self->am_inl_hdr.rc_hdr, 0)
          status = uct_iface_mpool_init -> 创建地址控制器和原子内存池
          uct_rc_verbs_iface_init_inl_wrs
          status = uct_rc_init_fc_thresh(&config->super, &self->super)
          status = uct_rc_iface_qp_create
          uct_ib_destroy_qp(qp)
      uct_iface_progress_enable(iface_p->iface -> uct_base_iface_progress_enable_cb -> uct_rc_verbs_iface_common_progress_enable
        uct_rc_verbs_iface_common_prepost_recvs(iface)
          uct_rc_verbs_iface_post_recv_common
            uct_rc_verbs_iface_post_recv_always
              uct_ib_iface_prepare_rx_wrs
                UCT_TL_IFACE_GET_RX_DESC(&iface->super, mp, desc, break) -> ucs_mpool_get_inline
                  ucs_mpool_get_grow
                    ucs_mpool_grow -> chunk_alloc -> uct_iface_mp_chunk_alloc
                      uct_iface_mem_alloc
                    ...
                    ibv_reg_mr_iova2
              ibv_post_srq_recv  
      uct_rc_verbs_iface_progress(search) -> 驱动接口运转
        ucs_callbackq_add_safe
      status = uct_iface_query(iface_p->iface, &iface_p->iface_attr) -> uct_rc_verbs_iface_query
        status = uct_rc_iface_query
          status = uct_ib_iface_query -> ucs_status_t uct_ib_iface_query
            static const uint8_t ib_port_widths[] = {[1] = 1, [2] = 4, [4] = 8, [8] = 12, [16] = 2};
            uct_base_iface_query(&iface->super, iface_attr)
            active_width = uct_ib_iface_port_attr(iface)->active_width
            case UCT_IB_SPEED_EDR -> 网卡速度
              iface_attr->latency.c = 600e-9
              signal_rate           = 25.78125e9
              encoding              = 64.0/66.0
            num_path   = uct_ib_iface_is_roce(iface) 
          uct_ib_device_has_pci_atomics(dev))
        iface_attr->latency.m += 1e-9 -> 1ns 纳秒
        iface_attr->overhead   = 75e-9
        iface_attr->ep_addr_len = uct_ib_md_is_flush_rkey_valid
  status = uct_iface_set_am_handler(if_info.iface, id, hello_world, &cmd_args.func_am_type, 0) -> 设置服务端接收到客户端数据后的回调
    iface->am[id].cb    = cb
  connect_common
    ret = getaddrinfo(server, service, &hints, &res)
    sockfd = socket(t->ai_family, t->ai_socktype, t->ai_protocol)
    setsockopt
    bind, listen, accept -> 等待客户端发起socket连接
  status = uct_iface_get_device_address(if_info.iface, own_dev)
  sendrecv(oob_sock, own_dev, if_info.iface_attr.device_addr_len, (void**)&peer_dev) -> 先通过socket发送和接收长度, 然后发送和接收地址, 交换地址
  uct_iface_is_reachable 检查地址是否可达 -> uct_ib_iface_is_reachable_v2 -> static int uct_ib_iface_dev_addr_is_reachable -> ucs_test_all_flags
    device_addr = (const uct_ib_address_t*) UCS_PARAM_VALUE -> 如果设置了字段掩码中的标志，则有条件地返回参数值。 否则，返回默认值
  status = uct_ep_create(&ep_params, &ep) -> 创建新端点 -> UCS_CLASS_DEFINE_NEW_FUNC
  ucs_vfs_obj_set_dirty(params->iface, uct_iface_vfs_refresh)
    ucs_vfs_global_init() -> UCS_INIT_ONCE(&ucs_vfs_init_once) 单例
    ucs_vfs_node_find_by_obj -> ucs_vfs_kh_find -> klib -> kh_get -> 独立且轻量级c库: https://github.com/attractivechaos/klib
  ucs_status_t uct_rc_verbs_ep_get_address
  status = uct_ep_connect_to_ep(ep, peer_dev, peer_ep) -> uct_rc_verbs_ep_connect_to_ep_v2
    status = uct_rc_iface_qp_connect(iface, ep->qp, qp_num, &ah_attr, path_mtu) -> ucs_status_t uct_rc_iface_qp_connect
      qp_attr.qp_state              = IBV_QPS_RTR -> 设备qp
      ret = ibv_modify_qp(qp, &qp_attr, qp_attr_mask); -> 设置qp状态机
      ...
      qp_attr.qp_state              = IBV_QPS_RTS
      ret = ibv_modify_qp(qp, &qp_attr, qp_attr_mask)
      ucs_debug("connected rc qp 0x%x on " -> 打印debug日志 -> connected rc qp 0x1a91b on mlx5_0:1/RoCE to lid 49152(+0) sl 0 remote_qp 0x1a91a mtu 1024 timer 18x7 rnr 13x7 rd_atom 16
  uct_worker_progress(if_info.worker) -> UCT 工作人员的显着进展。 该例程显式地处理任何未完成的通信操作和活动消息请求 -> uct_rc_verbs_iface_progress
    count = uct_rc_verbs_iface_poll_rx_common(iface) -> ibv_poll_cq
      uct_rc_verbs_iface_post_recv_common(iface, 0)
    return count + uct_rc_verbs_iface_poll_tx(iface) -> always_inline
      UCT_RC_VERBS_IFACE_FOREACH_TXWQE(&iface->super, i, wc, num_wcs) -> 遍历宏
      uct_rc_txqp_completion_desc
      ucs_arbiter_group_schedule -> 安排一个小组进行仲裁。 如果该组已经存在，则该操作将无效
      uct_rc_verbs_update_tx_res(&iface->super, ep, count)
        uct_rc_txqp_available_add
        uct_rc_iface_update_reads -> 将 RDMA_READ 积分释放回 RC iface。 RDMA_READ 积分在完成回调中释放，但不会释放到 RC iface 以避免 OOO 发送。 否则，如果读取信用是唯一缺少的资源并在完成回调中释放，则即使挂起队列不为空，下一个完成回调也将能够发送
        uct_rc_iface_add_cq_credits -> UCT/IB：修复错误处理后清除待处理请求的问题
      ucs_arbiter_dispatch(&iface->super.tx.arbiter, 1, uct_rc_ep_process_pending, NULL) -> 在仲裁器中调度工作元素。 对于每个组，只要回调返回 REMOVE_ELEM 或 NEXT_GROUP，最多会调度 per_group 工作元素。 然后，对下一组执行相同的操作，直到仲裁器变空或回调返回 STOP。 如果一个组没有元素，或其回调返回 REMOVE_GROUP，则它将被删除，直到使用 ucs_arbiter_group_schedule() 将其放回到仲裁器上
  if (barrier(oob_sock, progress_worker, if_info.worker)) -> TCP/TEST：修复 ucp_hello_world 同时 ep close 的问题
  out_free_ep -> 释放资源
  ...


server:
while (desc_holder == NULL) 
uct_worker_progress(if_info.worker) -> static inline unsigned ucs_callbackq_dispatch -> count += cb(elem->arg)
  static unsigned uct_rc_verbs_iface_progress(void *arg) <- self->super.progress
    count = uct_rc_verbs_iface_poll_rx_common(iface)
      uct_rc_verbs_iface_handle_am
        uct_iface_invoke_am
          status = handler->cb(handler->arg, data, length, flags) -> hello_world -> 服务端收到数据后回调
            print_strings




uct_iface_progress_enable
  uct_iface_progress -> return iface->ops.iface_progress(iface)
    uct_rc_iface_do_progress <- .iface_progress
      return iface->progress(iface)
      



typedef struct ucs_mpmc_queue, 多生产者多消费者线程安全队列。 在“良好”场景中，每次推/拉都是一个原子操作

typedef struct uct_tl_resource_desc, 通信资源描述符。 资源描述符是表示网络资源的对象。 资源描述符可以表示独立的通信资源（例如HCA端口、网络接口）或多个资源（例如多个网络接口或通信端口）。 它还可以表示通过单个物理网络接口定义的虚拟通信资源

md_resources, 内存域资源数组。 使用时，应在使用指向数组的指针调用 @ref uct_component_query 之前对其进行初始化，该数组足够大以容纳所有内存域资源条目。 调用后，该数组将填充现有内存域资源的信息。 为了分配该数组，您可以调用@ref uct_component_query两次：第一次将仅通过在field_mask中指定@ref UCT_COMPONENT_ATTR_FIELD_MD_RESOURCE_COUNT来获取所需的条目数量。 然后，可以为数组分配返回的条目数，并传递给对 @ref uct_component_query 的第二次调用，这次将 field_mask 设置为 @ref UCT_COMPONENT_ATTR_FIELD_MD_RESOURCES



connect_common
uct_iface_get_device_address
sendrecv
status = uct_ep_create(&ep_params, &ep)
uct_rc_verbs_ep_connect_to_ep_v2




client:
[root@node63 ucx]# /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs -n 172.17.29.63 -z
...
if (connect(sockfd, t->ai_addr, t->ai_addrlen) == 0)

examples/uct_hello_world.c -> int main(int argc, char **argv)
if (parse_cmd(argc, argv, &cmd_args)) -> 解析命令行参数
ucs_async_context_create
uct_worker_create
dev_tl_lookup
status = uct_iface_set_am_handler(if_info.iface, id, hello_world -> 设置接收到数据后的回调
connect_common
uct_iface_get_device_address
uct_iface_get_address
uct_ep_create
sendrecv
char *str = (char *)mem_type_malloc(cmd_args.test_strlen) -> 分配16字节的字符, malloc | cudaMalloc | cudaMallocManaged
generate_test_string
  memcpy(dst, src, count) -> 拷贝16字节的字符串到str
do_am_zcopy(&if_info, ep, id, &cmd_args, str) -> 
  uct_md_mem_reg -> uct_ib_mlx5_devx_mem_reg
    mr = UCS_PROFILE_CALL_ALWAYS(ibv_reg_mr, md->pd, address, length, access_flags) -> 注册该段内存
  iov.buffer = buf
  iov.memh   = memh -> 空指针
  ...
if (barrier(oob_sock, progress_worker, if_info.worker))

...
ucs_status_t do_am_short
  UCT_INLINE_API ucs_status_t uct_ep_am_short
    ucs_status_t uct_rc_verbs_ep_am_short
      uct_rc_verbs_iface_fill_inl_am_sge
      uct_rc_verbs_ep_post_send
        ibv_post_send



(gdb) b ibv_create_qp
#0  0x00007ffff65347b0 in ibv_create_qp () from /lib64/libibverbs.so.1
#1  0x00007ffff6778a58 in uct_rc_verbs_can_create_qp (ctx=<optimized out>, pd=0x60d3f0) at rc/verbs/rc_verbs_iface.c:556
#2  0x00007ffff6778c23 in uct_rc_verbs_query_tl_devices (md=0x60efd0, tl_devices_p=0x7fffffffd630, num_tl_devices_p=0x7fffffffd620) at rc/verbs/rc_verbs_iface.c:581
#3  0x00007ffff792864f in uct_md_query_tl_resources (md=0x60efd0, resources_p=resources_p@entry=0x7fffffffd7b0, num_resources_p=num_resources_p@entry=0x7fffffffd790) at base/uct_md.c:94
#4  0x000000000040248c in dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:363
#5  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611
(gdb) c
(gdb) bt
#0  0x00007ffff65347b0 in ibv_create_qp () from /lib64/libibverbs.so.1
#1  0x00007ffff675db21 in ibv_create_qp_ex (qp_init_attr_ex=0x7fffffffd558, context=<optimized out>) at /usr/include/infiniband/verbs.h:3016
#2  uct_ib_iface_create_qp (iface=iface@entry=0x6160f0, attr=attr@entry=0x7fffffffd520, qp_p=qp_p@entry=0x7fffffffd4e0) at base/ib_iface.c:1024
#3  0x00007ffff677238b in uct_rc_iface_qp_create (iface=iface@entry=0x6160f0, qp_p=qp_p@entry=0x7fffffffd4e0, attr=attr@entry=0x7fffffffd520, max_send_wr=<optimized out>, srq=<optimized out>)
    at rc/base/rc_iface.c:838
#4  0x00007ffff67794ed in uct_rc_verbs_iface_t_init (tl_config=0x60e130, params=<optimized out>, worker=<optimized out>, tl_md=<optimized out>, _init_count=0x7fffffffd4d0, 
    _myclass=0x7ffff69fc760 <uct_rc_verbs_iface_t_class>, self=0x6160f0) at rc/verbs/rc_verbs_iface.c:357
#5  uct_rc_verbs_iface_t_new (arg0=<optimized out>, arg1=<optimized out>, arg2=<optimized out>, arg3=0x60e130, obj_p=0x7fffffffdcd8) at rc/verbs/rc_verbs_iface.c:461
#6  0x00007ffff7928b5b in uct_iface_open (md=0x60efd0, worker=0x607560, params=params@entry=0x7fffffffd820, config=0x60e130, iface_p=iface_p@entry=0x7fffffffdcd8) at base/uct_md.c:250
#7  0x0000000000402738 in init_iface (iface_p=0x7fffffffdac0, func_am_type=FUNC_AM_SHORT, tl_name=0x616010 "rc_verbs", dev_name=0x61601a "mlx5_0:1") at uct_hello_world.c:271
#8  dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:383
#9  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611


利用宏, 注册传输层:
UCT_TL_DEFINE_ENTRY(&uct_ib_component, rc_verbs, uct_rc_verbs_query_tl_devices,
                    uct_rc_verbs_iface_t, "RC_VERBS_",
                    uct_rc_verbs_iface_config_table,
                    uct_rc_verbs_iface_config_t);

UCT_TL_DEFINE_ENTRY(&uct_tcp_component, tcp, uct_tcp_query_devices,


已注册的传输层类型, 搜索关键字(UCT_TL_DEFINE_ENTRY)
uct_tl_t uct_rc_verbs_tl = { .name = "rc_verbs", .query_devices = uct_rc_verbs_query_tl_devices, .iface_open = uct_rc_verbs_iface_t_new, .config = { .name = "rc_verbs"" transport", .prefix = "RC_VERBS_", .table = uct_rc_verbs_iface_config_table, .size = sizeof(uct_rc_verbs_iface_config_t), } };


rc_verbs
ud_mlx5
ud_verbs
cma
knem
self
tcp



网卡,传输层操作, uct_rc_verbs_iface_tl_ops


创建完成队列:
#0  0x00007ffff65345c0 in ibv_create_cq () from /lib64/libibverbs.so.1
#1  0x00007ffff67694dc in uct_ib_mlx5_devx_open_device (ibv_device=ibv_device@entry=0x60de40) at mlx5/dv/ib_mlx5dv_md.c:947
#2  0x00007ffff676cfd8 in uct_ib_mlx5_devx_md_open (ibv_device=0x60de40, md_config=0x607750, p_md=0x7fffffffd5e0) at mlx5/dv/ib_mlx5dv_md.c:1111
#3  0x00007ffff6760d04 in uct_ib_md_open (component=<optimized out>, md_name=0x7fffffffd680 "mlx5_0", uct_md_config=0x607750, md_p=0x7fffffffd640) at base/ib_md.c:1051
#4  0x00007ffff792852d in uct_md_open (component=0x7ffff69faf40 <uct_ib_component>, md_name=0x7fffffffd680 "mlx5_0", config=<optimized out>, md_p=md_p@entry=0x7fffffffddc0) at base/uct_md.c:61
#5  0x0000000000402427 in dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:352
#6  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611

#0  0x00007ffff65345c0 in ibv_create_cq () from /lib64/libibverbs.so.1
#1  0x00007ffff6778a39 in uct_rc_verbs_can_create_qp (ctx=<optimized out>, pd=0x60d3f0) at rc/verbs/rc_verbs_iface.c:546
#2  0x00007ffff6778c23 in uct_rc_verbs_query_tl_devices (md=0x60efd0, tl_devices_p=0x7fffffffd630, num_tl_devices_p=0x7fffffffd620) at rc/verbs/rc_verbs_iface.c:581
#3  0x00007ffff792864f in uct_md_query_tl_resources (md=0x60efd0, resources_p=resources_p@entry=0x7fffffffd7b0, num_resources_p=num_resources_p@entry=0x7fffffffd790) at base/uct_md.c:94
#4  0x000000000040248c in dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:363
#5  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611

#0  0x00007ffff65347b0 in ibv_create_qp () from /lib64/libibverbs.so.1
#1  0x00007ffff675db21 in ibv_create_qp_ex (qp_init_attr_ex=0x7fffffffd558, context=<optimized out>) at /usr/include/infiniband/verbs.h:3016
#2  uct_ib_iface_create_qp (iface=iface@entry=0x6160f0, attr=attr@entry=0x7fffffffd520, qp_p=qp_p@entry=0x7fffffffd4e0) at base/ib_iface.c:1024
#3  0x00007ffff677238b in uct_rc_iface_qp_create (iface=iface@entry=0x6160f0, qp_p=qp_p@entry=0x7fffffffd4e0, attr=attr@entry=0x7fffffffd520, max_send_wr=<optimized out>, srq=<optimized out>)
    at rc/base/rc_iface.c:838
#4  0x00007ffff67794ed in uct_rc_verbs_iface_t_init (tl_config=0x60e130, params=<optimized out>, worker=<optimized out>, tl_md=<optimized out>, _init_count=0x7fffffffd4d0, 
    _myclass=0x7ffff69fc760 <uct_rc_verbs_iface_t_class>, self=0x6160f0) at rc/verbs/rc_verbs_iface.c:357
#5  uct_rc_verbs_iface_t_new (arg0=<optimized out>, arg1=<optimized out>, arg2=<optimized out>, arg3=0x60e130, obj_p=0x7fffffffdcd8) at rc/verbs/rc_verbs_iface.c:461
#6  0x00007ffff7928b5b in uct_iface_open (md=0x60efd0, worker=0x607560, params=params@entry=0x7fffffffd820, config=0x60e130, iface_p=iface_p@entry=0x7fffffffdcd8) at base/uct_md.c:250
#7  0x0000000000402738 in init_iface (iface_p=0x7fffffffdac0, func_am_type=FUNC_AM_SHORT, tl_name=0x616010 "rc_verbs", dev_name=0x61601a "mlx5_0:1") at uct_hello_world.c:271
#8  dev_tl_lookup (cmd_args=cmd_args@entry=0x7fffffffda00, iface_p=iface_p@entry=0x7fffffffdac0) at uct_hello_world.c:383
#9  0x000000000040193b in main (argc=<optimized out>, argv=<optimized out>) at uct_hello_world.c:611


help, 帮助, 选项, 参数:
[root@node63 ucx]# /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -h
Usage: uct_hello_world [parameters]
UCT hello world client/server example utility

Parameters are:
  -i      Select "uct_ep_am_short" function to send the message (default) // 默认短消息
  -b      Select "uct_ep_am_bcopy" function to send the message // 缓冲区
  -z      Select "uct_ep_am_zcopy" function to send the message // 零拷贝
  -d        Select device name
  -t        Select transport layer
  -n <name> Set node name or IP address of the server (required for client and should be ignored for server)
  -p <port>     Set alternative server port (default:13337)
  -6            Use IPv6 address in data exchange
  -s <size>     Set test string length (default:16)
  -m <mem type> Memory type of messages
                host - system memory (default)
                cuda - NVIDIA GPU memory
                cuda-managed - NVIDIA GPU managed/unified memory

Example:
  Server: uct_hello_world -d eth0 -t tcp
  /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs

  Client: uct_hello_world -d eth0 -t tcp -n localhost
  /home/xb/project/ucx/examples/.libs/lt-uct_hello_world -d mlx5_0:1 -t rc_verbs -n 172.17.29.63


typedef struct uct_iface_ops 传输接口操作，API 中公开的每个操作都必须出现在下表中，以允许使用自定义操作创建接口/端点
ep_fence, 端点栅栏, 

typedef struct uct_worker, 进程引擎和用于分配通信资源的域。 不同工人独立驱动


ucs_status_t uct_ep_create, 创建新端点。 以可用模式之一创建 UCT 端点： -# 未连接端点：如果 uct_ep_params 中不存在任何地址，则会创建一个未连接端点。 要建立到远程端点的连接，需要调用 uct_ep_connect_to_ep  使用此模式需要 uct_ep_params_t::iface 具有 UCT_IFACE_FLAG_CONNECT_TO_EP 功能标志。 可以通过 uct_iface_query 获取。 -# 连接到远程接口：如果设置了 uct_ep_params_t::dev_addr 和 uct_ep_params_t::iface_addr，这将建立一个连接到远程接口的端点。 这要求 uct_ep_params_t::iface 具有 UCT_IFACE_FLAG_CONNECT_TO_IFACE 功能标志。 可以通过uct_iface_query获取。 -# 连接到远程套接字地址：如果设置了 uct_ep_params_t::sockaddr，这将创建一个连接到远程套接字的端点。 这要求设置 uct_ep_params::cm 或 uct_ep_params::iface。 在后一种情况下，接口必须支持 UCT_IFACE_FLAG_CONNECT_TO_SOCKADDR 标志，可以通过调用 uct_iface_query 来检查该标志。

参数：
[in] – params 用户为 ep_p 定义的 uct_ep_params_t 配置。
[out] – ep_p 填充新端点的句柄。

返回：
UCS_OK 端点创建成功。 这并不能保证端点已连接到参数中定义的目的地； 如果失败，错误将报告给通过 uct_iface_params_t.err_handler 提供给 uct_iface_open 的接口错误处理回调。 ucs_status_t 定义的错误代码


ucs_async_thread_add_event_fd
status = ucs_async_thread_start(&thread)
ucs_pthread_create(&thread->thread_id, ucs_async_thread_func




flow:
接口(uct_iface) -----> 操作(uct_iface_ops_t)
端点(uct_ep_h) 中包含 iface_操作




conjunction 连接
typedef struct uct_ib_address IB网络地址

UCS_CLASS_DEFINE_NEW_FUNC(uct_rc_verbs_ep_t, uct_ep_t, const uct_ep_params_t *); 宏展开
ucs_status_t uct_rc_verbs_ep_t_new(const uct_ep_params_t * arg0,  uct_ep_t **obj_p) 
{ 
  ucs_status_t status; 
  *obj_p = ((void *)0); 
  status = ({ ucs_class_t *cls = &uct_rc_verbs_ep_t_class; ucs_status_t _status; void *obj; obj = ucs_class_malloc(cls); 
  if (obj != ((void *)0)) 
  { 
    _status = ({ ucs_class_t *_cls = &uct_rc_verbs_ep_t_class; 
    int _init_counter = 1; 
    ucs_status_t __status; 
    __status = uct_rc_verbs_ep_t_init((uct_rc_verbs_ep_t*)(obj), _cls, &_init_counter,arg0); 
    if (__status != UCS_OK) { 
      ucs_class_call_cleanup_chain(&uct_rc_verbs_ep_t_class, (obj), _init_counter); 
    } (__status); }); 
    if (_status == UCS_OK) { *(obj_p) = (__typeof__(*(obj_p)))obj; } else { ucs_class_free(obj); *(obj_p) = ((void *)0); } } else { _status = UCS_ERR_NO_MEMORY; *(obj_p) = ((void *)0); } (_status); }); ucs_class_check_new_func_result(status, *obj_p); return status; }


数据结构: src/ucs/datastruct


日志级别: 
ucs_global_opts_table
export UCX_LOG_LEVEL=debug

ucs_init
  ucs_global_opts_init
    status = ucs_config_parser_fill_opts(&ucs_global_opts, UCS_CONFIG_GET_TABLE(ucs_global_opts_read_only_table), UCS_DEFAULT_ENV_PREFIX, 1); -> 配置文件 , 全局只读配置表 -> static ucs_config_field_t ucs_global_opts_read_only_table[] 
    static ucs_config_field_t ucs_global_opts_table[] -> 全局选项表
      ucs_config_parse_config_file
        file = fopen(file_path, "r"); -> 读取配置文件
        "/home/xb/project/ucx/install-debug/etc/ucx" -> 优先查找路径
    ucs_vfs_obj_add_dir(NULL, &ucs_global_opts, "ucs/global_opts")
    ucs_vfs_obj_add_rw_file(&ucs_global_opts, ucs_vfs_read_log_level, ucs_vfs_write_log_level, NULL, 0, "log_level")


io示例: buildlib/pr/io_demo/az-stage-io-demo.yaml



uct_rc_verbs_iface_common_progress_enable


typedef struct uct_rc_verbs_txcnt {
    uint16_t       pi;      /* producer (post_send) count */  生产者提交计数
    uint16_t       ci;      /* consumer (ibv_poll_cq) completion count */ 消费者完成计数
} uct_rc_verbs_txcnt_t;


仲裁者:
/*
 *  A mechanism to arbitrate among groups of queued work elements, which attempts
 * to be "fair" with respect to the groups.
 *
 * - "Arbiter" - the top-level entity.
 * - "Element" - a single work element.
 * - "Group"   - queue of work elements which would be dispatched in-order
 *
 * The arbiter contains a double-linked list of the group head elements. The
 * next group head to be dispatched is the first entry in the list. Whenever a
 * group is rescheduled, it's moved to the tail of the list. At any point, a
 * group head can be removed from the "middle" of the list.
 *
 * The groups and elements are arranged like this:
 *  - every arbitrated element points to the group (head).
 *  - first element in the group points to previous and next group (list)
 *  - first element in the group points to the first element of next group (next_group).
 *  - all except last element point to the next element in same group, and the
 *    last one points to the first (next).
 *
 * Note:
 *  Every element holds 4 pointers. It could be done with 3 pointers, so that
 *  the pointer to the previous group is put instead of "next" pointer in the last
 *  element in the group, when it is put on the arbiter queue. However, it makes
 *  the code much more complicated.
 *
 *
 * Arbiter:
 *   +=============+
 *   | list        +
 *   +======+======+
 *   | next | prev |
 *   +==|===+===|==+
 *      |       +----------------------------------------------+
 *      |                                                      |
 *      +------+                                               |
 *             |                                               |
 *             |                                               |
 * Elements:   V                                               V
 *       +------------+          +------------+          +------------+
 *       | list       |<-------->| list       |<-------->| list       |
 *       +------------+          +------------+          +------------+
 *    +->| next       +---+   +->| next       +---+      + next       +
 *    |  +------------+   |   |  +------------+   |      +------------+
 *    |  | group      |   |   |  | group      |   |      | group      |
 *    |  +------------+   |   |  +------------+   |      +--------+---+
 *    |                   |   |                   |          ^    |
 *    |                   |   |                   |          |    |
 *    |  +------------+   |   |  +------------+   |          |    |
 *    |  | list       |<--+   |  | list       |<--+          |    |
 *    |  +------------+       |  +------------+              |    |
 *    +--+ next       +       +--+ next       |              |    |
 *       +------------+          +------------+              |    |
 *       | group      |          | group      |              |    |
 *       +---------+--+          +--------+---+              |    |
 *            ^    |                 ^    |                  |    |
 * Groups:    |    |                 |    |                  |    |
 *            |    |                 |    |                  |    |
 *     +------+    |          +------+    |           +------+    |
 *     | tail |<---+          | tail |<---+           | tail |<---+
 *     +------+               +------+                +------+
 *
 */

typedef struct ucs_arbiter        ucs_arbiter_t;

一种在排队的工作元素组之间进行仲裁的机制，它试图对组进行“公平”
- “仲裁者” - 顶级实体。
- “元素”   - 单个工作元素。
-“组”      -将按顺序分派的工作元素队列，仲裁器包含组头元素的双链表。 下一个要分派的组头是列表中的第一个条目。 每当重新安排一个组时，它就会移至列表的末尾。 在任何时候，都可以从列表的“中间”删除组头。
组和元素的排列如下：
  - 每个仲裁元素都指向该组（头）。
  - 组中的第一个元素指向上一个和下一个组（列表）
  - 组中的第一个元素指向下一个组 (next_group) 的第一个元素。
  - 除最后一个元素外的所有元素都指向同一组中的下一个元素，最后一个元素指向第一个（下一个）。
注意：每个元素有4个指针。 可以使用 3 个指针来完成，以便当将其放入仲裁器队列时，将指向前一组的指针而不是组中最后一个元素中的“下一个”指针放入。 但是，这使得代码变得更加复杂





数据结构, data_struct
ucs_async_context


创建工人的宏展开: 声明/定义一个创建类实例的函数
ucs_status_t uct_worker_create(ucs_async_context_t* arg0, ucs_thread_mode_t arg1,  uct_worker_t **obj_p) { 
  ucs_status_t status; 
  *obj_p = ((void *)0); 
  status = ({ ucs_class_t *cls = &uct_priv_worker_t_class; ucs_status_t _status; void *obj; obj = ucs_class_malloc(cls); 
  if (obj != ((void *)0)) { 
    _status = ({ ucs_class_t *_cls = &uct_priv_worker_t_class; int _init_counter = 1;
    ucs_status_t __status; 
    __status = uct_priv_worker_t_init((uct_priv_worker_t*)(obj), _cls, &_init_counter,arg0 , arg1); 
    if (__status != UCS_OK) { 
      ucs_class_call_cleanup_chain(&uct_priv_worker_t_class, (obj), _init_counter);
    } 
    (__status); }); 
    if (_status == UCS_OK) { *(obj_p) = (__typeof__(*(obj_p)))obj; } else { ucs_class_free(obj); *(obj_p) = ((void *)0); } } else { _status = UCS_ERR_NO_MEMORY; *(obj_p) = ((void *)0); } (_status); }); ucs_class_check_new_func_result(status, *obj_p); return status; }




常用宏(预处理器): src/ucs/sys/preprocessor.h
/* Convert token to string */
#define UCS_PP_QUOTE(x)                   # x

/* Expand macro token to the macro value */
#define UCS_PP_EXPAND(x)                  x

/* Paste two expanded tokens */
#define __UCS_TOKENPASTE_HELPER(x, y)     x ## y
#define UCS_PP_TOKENPASTE(x, y)           __UCS_TOKENPASTE_HELPER(x, y)

/* Paste three expanded tokens */
#define __UCS_TOKENPASTE3_HELPER(x, y, z) x ## y ## z
#define UCS_PP_TOKENPASTE3(x, y, z)       __UCS_TOKENPASTE3_HELPER(x, y, z)

/* Unique value generator */
#ifdef __COUNTER__
#  define UCS_PP_UNIQUE_ID __COUNTER__
#else
#  define UCS_PP_UNIQUE_ID __LINE__
#endif

/* Creating unique identifiers, used for macros */
#define UCS_PP_APPEND_UNIQUE_ID(x)        UCS_PP_TOKENPASTE(x, UCS_PP_UNIQUE_ID)

/* Convert to string */
#define _UCS_PP_MAKE_STRING(x)            #x
#define UCS_PP_MAKE_STRING(x)             _UCS_PP_MAKE_STRING(x)




面向对象:
struct uct_rc_iface {
    uct_ib_iface_t              super;

类: 
typedef struct ucs_class     ucs_class_t;
struct ucs_class {
    const char               *name;
    size_t                   size;
    ucs_class_t              *superclass;
    ucs_class_init_func_t    init;
    ucs_class_cleanup_func_t cleanup;
};

typedef struct uct_priv_worker {
    uct_worker_t           super;
    ucs_async_context_t    *async;
    ucs_thread_mode_t      thread_mode;
    ucs_list_link_t        tl_data;
} uct_priv_worker_t;


/**
 * IB port active speed. IB端口速度
 */
enum {
    UCT_IB_SPEED_SDR     = 1,
    UCT_IB_SPEED_DDR     = 2,
    UCT_IB_SPEED_QDR     = 4,
    UCT_IB_SPEED_FDR10   = 8,
    UCT_IB_SPEED_FDR     = 16,
    UCT_IB_SPEED_EDR     = 32,
    UCT_IB_SPEED_HDR     = 64,
    UCT_IB_SPEED_NDR     = 128,
    UCT_IB_SPEED_LAST
};



注册tl, 传输层
_dl_init_internal
void UCS_F_CTOR uct_init()
uct_self_init() -> UCT_SINGLE_TL_INIT(&uct_self_component, self,,,)
   void uct_self_init(void) { {; uct_component_register(&uct_self_component);}; uct_tl_register(&uct_self_component, &uct_self_tl); }  
   void uct_self_cleanup(void) { uct_tl_unregister(&uct_self_tl); {uct_component_unregister(&uct_self_component); ;}; }
uct_tl_register
  ucs_list_add_tail(&component->tl_list, &tl->list)



所有IB传输层类型(tl):
static uct_tl_t *uct_ib_tls[] = {
#ifdef HAVE_TL_DC
    &UCT_TL_NAME(dc_mlx5),
#endif
#ifdef HAVE_TL_RC
    &UCT_TL_NAME(rc_verbs),
#endif
#if defined (HAVE_TL_RC) && defined (HAVE_MLX5_DV)
    &UCT_TL_NAME(rc_mlx5),
#endif
#ifdef HAVE_TL_UD
    &UCT_TL_NAME(ud_verbs),
#endif
#if defined (HAVE_TL_UD) && defined (HAVE_MLX5_HW_UD)
    &UCT_TL_NAME(ud_mlx5)
#endif
};


类: src/ucs/type/class.h


wireup, 连线


网络插件:
● ofi: Libfabric (OpenFabrics Interfaces)**
● portals4: Portals-based networks (uncommon)
● self: Process-loopback communications
● sm: Shared memory
● smcuda: CUDA-aware shared memory
● tcp: TCP
● uct: UCX**
● ugni: Cray uGNI (userspace Generic Network Interface)**
● usnic: Cisco usNIC (userspace NIC)



环境变量前缀与配置文件名:
#define UCS_DEFAULT_ENV_PREFIX "UCX_"
#define UCS_CONFIG_ARRAY_MAX   128
#define UCX_CONFIG_FILE_NAME   "ucx.conf"

全局选项配置:
ucs_global_opts_t ucs_global_opts = {
    .log_component         = {UCS_LOG_LEVEL_WARN, "UCX", "*"},
    .log_print_enable      = 0,
    .log_file              = "",
    .log_file_size         = SIZE_MAX,
    .log_file_rotate       = 0,
    .log_buffer_size       = 1024,
    .log_data_size         = 0,
    .mpool_fifo            = 0,
    .handle_errors         = UCS_BIT(UCS_HANDLE_ERROR_BACKTRACE),
    .error_signals         = { NULL, 0 },
    .error_mail_to         = "",
    .error_mail_footer     = "",
    .gdb_command           = "gdb",
    .debug_signo           = SIGHUP,
    .log_level_trigger     = UCS_LOG_LEVEL_FATAL,
    .warn_unused_env_vars  = 1,
    .enable_memtype_cache  = UCS_TRY,
    .async_signo           = SIGALRM,
    .stats_dest            = "",
    .tuning_path           = "",
    .memtrack_dest         = "",
    .memtrack_limit        = UCS_MEMUNITS_INF,
    .stats_trigger         = "exit",
    .profile_mode          = 0,
    .profile_file          = "",
    .stats_filter          = { NULL, 0 },
    .stats_format          = UCS_STATS_FULL,
    .topo_prio             = { NULL, 0 },
    .vfs_enable            = 1,
    .vfs_thread_affinity   = 0,
    .rcache_check_pfn      = 0,
    .module_dir            = UCX_MODULE_DIR, /* defined in Makefile.am */ 模块搜索路径
    .module_log_level      = UCS_LOG_LEVEL_TRACE,
    .modules               = { {NULL, 0}, UCS_CONFIG_ALLOW_LIST_ALLOW_ALL },
    .arch                  = UCS_ARCH_GLOBAL_OPTS_INITALIZER,
    .rcache_stat_min       = 0,
    .rcache_stat_max       = 0
};



类型定义头文件: src/uct/api/uct_def.h



struct uct_md_attr
Memory domain attributes
} uct_md_attr_v2_t;
内存域属性。 该结构定义了内存域的属性，其中包括可分配的最大内存、访问内存所需的凭据、指示 CPU 邻近度的 CPU 掩码以及指示可分配的内存类型 (CPU/CUDA/ROCM) 的位图。 检测到的、分配的、访问的以及可以返回 dmabuf 属性的内存类型



static ucs_status_t uct_ib_verbs_md_open
  uct_ib_device_query
    status = uct_ib_query_device(dev->ibv_context, &dev->dev_attr)
      ret = ibv_query_device(ctx, attr) -> 查询网卡信息




ibv_get_device_list



typedef struct {
    double     bw_gbps;       /* Link speed */ 双精度,浮点数
    uint16_t   payload;       /* Payload used to data transfer */
    uint16_t   tlp_overhead;  /* PHY + data link layer + header + CRC */
    uint16_t   ctrl_ratio;    /* Number of TLC before ACK */
    uint16_t   ctrl_overhead; /* Length of control TLP */
    uint16_t   encoding;      /* Number of encoded symbol bits */
    uint16_t   decoding;      /* Number of decoded symbol bits */
    const char *name;         /* Name of PCI generation */
} ucs_topo_pci_info_t;


传输层包封装
MSC8156 技术数据表 (MSC8156)。 详细介绍了信号、AC/DC 特性、时钟信号特性、封装和引脚排列以及电气设计...
https://www.nxp.com/products/processors-and-microcontrollers/additional-mpu-mcus-architectures/digital-signal-processors/high-performance-six-core-dsp:MSC8156
/*
 * - TLP (Transaction Layer Packet) overhead calculations (no ECRC):
 *   Gen1/2:
 *     Start   SeqNum   Hdr_64bit   LCRC   End
 *       1   +   2    +   16      +   4  +  1  = 24
 *
 *   Gen3/4:
 *     Start   SeqNum   Hdr_64bit   LCRC
 *       4   +   2    +   16      +   4  = 26
 *
 * - DLLP (Data Link Layer Packet) overhead calculations:
 *    - Control packet 8b ACK + 8b flow control
 *    - ACK/FC ratio: 1 per 4 TLPs
 *
 * References:
 * [1] https://www.xilinx.com/support/documentation/white_papers/wp350.pdf
 * [2] https://xdevs.com/doc/Standards/PCI/PCI_Express_Base_4.0_Rev0.3_February19-2014.pdf
 * [3] https://www.nxp.com/docs/en/application-note/AN3935.pdf
 */

MSC8156 基于采用 StarCore® 技术构建的业界最高性能 DSP 内核，专为当今无线宽带、医疗成像、航空航天、国防以及先进测试和测量市场的高性能应用的高级处理要求和功能而设计。 它提供更高的性能和节能，在高度集成的片上系统 (SoC) 中利用 45 nm 处理技术，提供相当于 6 GHz 单核设备的性能。 MSC8156 帮助设备制造商创建最终产品和服务，在更小的硬件占用空间中集成更多功能。

MSC8156 DSP 提供高水平的性能和集成度，结合了六个完全可编程的增强型 SC3850 DSP 内核，每个内核的运行速度高达 1 GHz。 MAPLE-B 加速器由 NXP® 开发并集成在片上，支持 Turbo 和 Viterbi 通道解码以及 DFT/iDFT 和 FFT/iFFT 算法的硬件加速。 基于 RISC 的高性能内部 QUICC Engine® 子系统支持多种网络协议，以保证数据包网络上的可靠数据传输，同时显着减轻 DSP 内核的处理负担。

MSC8156嵌入大容量内部存储器，支持多种先进的高速接口类型，包括两个RapidIO®接口、两个用于网络通信的千兆位以太网接口、一个PCI Express®控制器、两个用于高速、行业标准存储器接口的DDR控制器 和四个多通道TDM 接口。 MSC8156 通过与所有 MSC825x 和 MSC815x DSP 设备的引脚兼容性实现了高度的可扩展性。


接口能力:
iface_attr->cap.flags       = UCT_IFACE_FLAG_AM_BCOPY        |
                              UCT_IFACE_FLAG_AM_ZCOPY        |
                              UCT_IFACE_FLAG_PUT_BCOPY       |
                              UCT_IFACE_FLAG_PUT_ZCOPY       |
                              UCT_IFACE_FLAG_GET_BCOPY       |
                              UCT_IFACE_FLAG_GET_ZCOPY       |
                              UCT_IFACE_FLAG_PENDING         |
                              UCT_IFACE_FLAG_CONNECT_TO_EP   |
                              UCT_IFACE_FLAG_CB_SYNC;
iface_attr->cap.event_flags = UCT_IFACE_FLAG_EVENT_SEND_COMP |
                              UCT_IFACE_FLAG_EVENT_RECV      |
                              UCT_IFACE_FLAG_EVENT_FD;




三种数据发送模式(活动消息):
/* Send active message to remote endpoint */
if (cmd_args.func_am_type == FUNC_AM_SHORT) {
    status = do_am_short(&if_info, ep, id, &cmd_args, str);
} else if (cmd_args.func_am_type == FUNC_AM_BCOPY) {
    status = do_am_bcopy(&if_info, ep, id, &cmd_args, str);
} else if (cmd_args.func_am_type == FUNC_AM_ZCOPY) {
    status = do_am_zcopy(&if_info, ep, id, &cmd_args, str);
}

短消息, 缓存区, 零拷贝
case 'i':
    args->func_am_type = FUNC_AM_SHORT;
    break;
case 'b':
    args->func_am_type = FUNC_AM_BCOPY;
    break;
case 'z':
    args->func_am_type = FUNC_AM_ZCOPY;


火焰图:
cd /home/xb/fire/FlameGraph
perf record -e cpu-clock  --call-graph dwarf -p 512634

perf script -i perf.data &> perf.unfold
./stackcollapse-perf.pl ./perf.unfold &> ../perf.folded
./flamegraph.pl ../perf.folded > ../perf.svg
sz -y ../perf.svg 


do_am_bcopy
  uct_ep_am_bcopy
    uct_rc_verbs_ep_am_bcopy
      UCT_RC_IFACE_GET_TX_AM_BCOPY_DESC
      ucs_mpool_get_inline
        status = uct_rc_verbs_ep_post_send_desc(ep, &wr, desc, send_flags | IBV_SEND_SOLICITED, UCT_IB_MAX_ZCOPY_LOG_SGE(&iface->super.super));
        UCT_RC_VERBS_FILL_DESC_WR(wr, desc) -> 将描述填充到工作请求, 新建sge与wr通过sgl关联
        uct_rc_verbs_ep_post_send(iface, ep, wr, send_flags, max_log_sge)
          ucs_assertv(ep->qp->state == IBV_QPS_RTS -> 队列对状态必须是准备发送
          uct_rc_iface_tx_moderation
          uct_rc_ep_fm
          uct_ib_log_post_send
          ret = ibv_post_send(ep->qp, wr, &bad_wr); -> 提交wr到qp的发送队列, 触发服务端收到消息后打印, print_strings
          uct_rc_verbs_txqp_posted -> 为DC(动态连接队列对 Dynamically Connected (DC) QPs)传输类型做准备, cq流控信用, 状态计数器等
        uct_rc_txqp_add_send_op_sn -> 提交发送后, 将io描述, 按序号sn插入outstanding队列, 因为在轮询完成时，我们可获得完成的数量（而不是基于完成的零索引）
          ucs_queue_push(&txqp->outstanding, &op->queue)


ucs_status_t do_am_zcopy
  uct_md_mem_reg -> UCS_PROFILE_CALL_ALWAYS(ibv_reg_mr -> 注册内存 -> 分析函数调用, 当 access_flags 包含 IBV_ACCESS_ON_DEMAND 时，ibv_reg_mr() 可能会失败并出现 EAGAIN。 这意味着预取由于与失效冲突而失败
    __ibv_reg_mr
  comp.uct_comp.func   = zcopy_completion_cb
  do ... while (status == UCS_ERR_NO_RESOURCE) -> 没资源时退出循环 
  status = uct_ep_am_zcopy -> ep->iface->ops.ep_am_zcopy
    ucs_status_t uct_rc_mlx5_ep_am_zcopy | uct_rc_verbs_ep_am_zcopy -> 可靠连接verbs端点的活动消息零拷贝
      UCT_CHECK_IOV_SIZE -> 检查向量IO个数, 应该不超过网卡最大发送(SGE-1), 第一个sge给header使用
      UCT_RC_CHECK_AM_ZCOPY -> 检查零拷贝参数
      UCT_RC_CHECK_RES_AND_FC -> 检查资源和流控参数
      UCT_RC_IFACE_GET_TX_AM_ZCOPY_DESC -> 从内存池获取发送端零拷贝内存描述 -> UCT/RC：使用恒定的标头大小，无论 TM 状态如何
      sge_cnt = uct_ib_verbs_sge_fill_iov(sge + 1, iov, iovcnt) -> 填充IO(将iov设置到sge上), 通过 uct_iov_t 中提供的数据填充 ibv_sge 数据结构 该函数避免复制零长度的 IOV
        sge[sge_it].addr   = (uintptr_t)(iov[iov_it].buffer) -> buffer地址转sge地址
        sge[sge_it].lkey = uct_ib_memh_get_lkey(iov[iov_it].memh) -> 设置本地键
      UCT_RC_VERBS_FILL_AM_ZCOPY_WR_IOV -> 准备工作请求wr, 将sge首地址和数量设置到wr, rdma操作码为发送(双边, IBV_WR_SEND)
        wr.sg_list = sge; wr.num_sge = (sge_cnt + 1); wr.opcode = (typeof(wr.opcode))IBV_WR_SEND;
      UCT_TL_EP_STAT_OP -> 统计发送状态
      uct_rc_verbs_ep_post_send_desc | status = uct_rc_mlx5_ep_zcopy_post(ep, MLX5_OPCODE_SEND, iov, iovcnt, 0ul, id, header, header_length, 0, 0, 0ul, 0, 0, MLX5_WQE_CTRL_SOLICITED, uct_rc_ep_send_op_completion_handler, 0, comp);
        ----------- rc_mlx5_iface 迈络思可靠连接接口的提交实现
        uct_rc_mlx5_txqp_dptr_post_iov
          uct_rc_mlx5_am_hdr_fill
          uct_ib_mlx5_inline_copy
          uct_rc_mlx5_common_post_send
            uct_ib_mlx5_post_send -> UCT/IB/MLX5：修复 TX WQ 溢出检查，当 WQE 恰好在 hw_ci+qp_length 结束时，当前检查失败，即使这是有效的情况，将溢出检查重构为特定断言并添加注释来解释它们，移动检查 函数到 C 文件，因为它不是快速路径
              num_bb  = ucs_div_round_up(wqe_size, MLX5_SEND_WQE_BB) -> 向上取大的
              uct_ib_mlx5_txwq_validate
              ucs_memory_cpu_store_fence -> 内存屏障 -> asm volatile(""::: "memory") -> 防止编译器重新排序指令
              *wq->dbrec = htonl(sw_pi += num_bb) -> 写门铃记录, volatile uint32_t           *dbrec;
              ucs_memory_bus_store_fence()
              ucs_likely uct_ib_mlx5_bf_copy
                uct_ib_mlx5_bf_copy_bb -> UCP/UCT/IB：修复UCT中的线程模式,当以“序列化”模式创建 IB 接口时，请确保刷新写入组合缓冲区，以避免在另一个线程使用同一 MMIO 寄存器时数据损坏
                  UCS_WORD_COPY(uint64_t, dst, uint64_t, src, MLX5_SEND_WQE_BB) -> UCT/IB：为 DM 字节复制循环解决无效的 GCC 矢量化问题 GCC 可以生成“movdqa”指令，该指令假定源缓冲区与 16 字节对齐，但是源缓冲区是由用户提供的，并且可能未对齐。 将源缓冲区类型声明为严格未对齐，以防止 GCC 进行无效矢量化
            uct_rc_txqp_posted
        uct_rc_txqp_add_send_comp
      UCT_RC_UPDATE_FC -> 更新流控
  uct_worker_progress




io描述
typedef struct uct_iov {
    void     *buffer;   /**< Data buffer */
    size_t    length;   /**< Length of the payload in bytes */
    uct_mem_h memh;     /**< Local memory key descriptor for the data */
    size_t    stride;   /**< Stride between beginnings of payload elements in
                             the buffer in bytes */
    unsigned  count;    /**< Number of payload elements in the buffer */
} uct_iov_t;


内联文件:
noinst_HEADERS += \
	mlx5/ib_mlx5_log.h \
	mlx5/ib_mlx5.h \
	mlx5/ib_mlx5.inl \
	mlx5/dv/ib_mlx5_dv.h \
	mlx5/dv/ib_mlx5_ifc.h


extern "C" static inline ucs_status_t uct_ep_am_zcopy(uct_ep_h ep, uint8_t id, const void *header, unsigned int header_length, const uct_iov_t *iov, size_t iovcnt, unsigned int flags, uct_completion_t *comp)
发送活动消息，同时避免本地内存复制 ::uct_iov_t 结构的 iov 数组中的输入数据发送到远程端（“收集输出”）。 iov 中的缓冲区按数组顺序进行处理。 这意味着函数在继续执行 iov[1] 之前完成 iov[0]，依此类推

参数：
[in] – ep 目标端点句柄。
[in] – id 活动消息 ID。 必须在 0..UCT_AM_ID_MAX-1 范围内。
[in] – header 活动消息头。
[in] – header_length 活动消息头长度（以字节为单位）。
[in] – iov 指向 ::uct_iov_t 结构数组。 iov 指针必须是 ::uct_iov_t 结构数组的有效地址。 特定的结构指针必须是有效的地址。 不需要 NULL 终止的数组。
[in] – iovcnt iov data ::uct_iov_t 结构数组的大小。 如果 iovcnt 为零，则数据被视为空。 iovcnt 受 uct_iface_attr_cap_am_max_iov "uct_iface_attr::cap::am::max_iov" 限制。
[in] – flags 活动消息标志，请参阅 uct_msg_flags。
[in] – 由 ::uct_completion_t 定义的 comp 完成句柄。

返回：
UCS_OK 操作成功完成。 UCS_INPROGRESS 某些通信操作仍在进行中。 如果提供了非 NULL comp，它将在完成这些操作后更新。 UCS_ERR_NO_RESOURCE 由于缺少发送资源而无法启动操作

笔记：
如果操作返回 UCS_INPROGRESS，则在 comp 完成操作之前，不得修改 iov 数组指向的内存缓冲区。 标头可以被释放或更改


test, google, ut, 单元测试, uct, 
gtest_SOURCES
gtest_SOURCES = common/main.cc
test/gtest/uct


test/gtest/common/main.cc -> main
  InitGoogleTest
  watchdog_start
  set_log_level
  RUN_ALL_TESTS
  watchdog_stop
  analyze_test_results



static inline ucs_status_t uct_iface_flush(uct_iface_h iface, unsigned int flags, uct_completion_t *comp)
刷新接口上未完成的通信操作。 刷新此调用之前在接口上发出的所有未完成的通信。 操作在原点或目标处完成。 确切的完成语义取决于 flags 参数。

参数：
[in] – iface 用于刷新通信的接口。
[in] – flags 控制完成语义的标志（当前仅支持 UCT_FLUSH_FLAG_LOCAL）。
[inout] – comp 完成句柄，由 uct_completion_t 定义。 可以为 NULL，这意味着调用将返回接口的当前状态，并且在未完成通信的情况下不会生成完成。 如果它不为 NULL，则调用完成时完成计数器会减 1。 当计数器达到 0 时调用完成回调

返回：
UCS_OK - 没有剩余的未完成的通信。 UCS_INPROGRESS - 某些通信操作仍在进行中。 如果提供了非 NULL 'comp'，它将在完成这些操作后更新


同: uct_ep_am_zcopy
static inline ucs_status_t uct_ep_put_zcopy(uct_ep_h ep, const uct_iov_t *iov, size_t iovcnt, uint64_t remote_addr, uct_rkey_t rkey, uct_completion_t *comp)



状态码, 错误码:
UCS_S_PACKED ucs_status_t;
为了评估从某个错误中恢复所需的必要步骤，外部 API 可返回的所有错误代码均按永久受错误影响的最大实体进行分组。 每个组的范围介于其 UCS_ERR_FIRST_<name> 和 UCS_ERR_LAST_<name> 枚举值之间。 例如，与端点级错误相比，如果链接失败，则可能足以销毁（并可能替换）它


/**
 * A queue of callback to execute
 */
struct ucs_callbackq {
    /**
     * Array of fast-path element, the last is reserved as a sentinel to mark
     * array end.
     */
    ucs_callbackq_elem_t           fast_elems[UCS_CALLBACKQ_FAST_COUNT + 1];  // 快速路径元素数组，最后一个元素被保留作为标记数组结束的标记
    ...
};




结构体字段对齐
struct mlx5_wqe_ctrl_seg {
	__be32		opmod_idx_opcode;
	__be32		qpn_ds;
	uint8_t		signature;
	__be16		dci_stream_channel_id;
	uint8_t		fm_ce_se;
	__be32		imm;
} __attribute__((__packed__)) __attribute__((__aligned__(4)));



数学库: src/ucs/sys/math.h



底层免拷贝:
static UCS_F_ALWAYS_INLINE void uct_ib_mlx5_bf_copy_bb(void * restrict dst,
                                                       void * restrict src)
{
#if defined( __SSE4_2__)
    UCS_WORD_COPY(__m128i, dst, __m128i, src, MLX5_SEND_WQE_BB);
#elif defined(__ARM_NEON)
    UCS_WORD_COPY(int16x8_t, dst, int16x8_t, src, MLX5_SEND_WQE_BB);
#else /* NO SIMD support */
    UCS_WORD_COPY(uint64_t, dst, uint64_t, src, MLX5_SEND_WQE_BB);
#endif
}



可重入自旋锁
typedef struct ucs_recursive_spinlock {
    ucs_spinlock_t super;
    int            count;
    pthread_t      owner;
} ucs_recursive_spinlock_t;


类方法: 
UCS_CLASS_INIT_FUNC -> 初始化



UCT组件及方法: 包含查询内存域资源, 打开内存域, 连接管理, rkey解包, rkey访问, rkey释放, rkey比较, 内存域配置条目, 连接管理配置条目, 传输列表, 链接到全局组件列表的链表, 标记位, 内存域对应的vfs初始化方法
struct uct_component {
    const char                              name[UCT_COMPONENT_NAME_MAX]; /**< Component name */
    uct_component_query_md_resources_func_t query_md_resources; /**< Query memory domain resources method */
    uct_component_md_open_func_t            md_open;            /**< Memory domain open method */
    uct_component_cm_open_func_t            cm_open;            /**< Connection manager open method */
    uct_component_rkey_unpack_func_t        rkey_unpack;        /**< Remote key unpack method */
    uct_component_rkey_ptr_func_t           rkey_ptr;           /**< Remote key access pointer method */
    uct_component_rkey_release_func_t       rkey_release;       /**< Remote key release method */
    uct_component_rkey_compare_func_t       rkey_compare;       /**< Remote key comparison method */
    ucs_config_global_list_entry_t          md_config;          /**< MD configuration entry */
    ucs_config_global_list_entry_t          cm_config;          /**< CM configuration entry */
    ucs_list_link_t                         tl_list;            /**< List of transports */
    ucs_list_link_t                         list;               /**< Entry in global list of components */
    uint64_t                                flags;              /**< Flags as defined by
                                                                     UCT_COMPONENT_FLAG_xx */
    /**< Memory domain initialize VFS method */
    uct_component_md_vfs_init_func_t        md_vfs_init;
};



配置解析器实现的方法:
配置变量格式
name: <env_prefix><table_prefix><field_name>
 * Examples of full variable names:
 *   - UCS_CIB_RNDV_THRESH
 *   - UCS_IB_TX_MODERATION
 */
typedef struct ucs_config_parser {
    int                      (*read) (const char *buf, void *dest, const void *arg);
    int                      (*write)(char *buf, size_t max,
                                      const void *src, const void *arg);
    ucs_status_t             (*clone)(const void *src, void *dest, const void *arg);
    void                     (*release)(void *ptr, const void *arg);
    void                     (*help)(char *buf, size_t max, const void *arg);
    const void               *arg;
} ucs_config_parser_t;


定义模块: AC_DEFINE_UNQUOTED([uct_MODULES], ["${uct_modules}"], [UCT loadable modules])

如果定义了共享库: #ifdef UCX_SHARED_LIB
注册模块: status = init_func()


动态模块名:
0x7fffffffb7b0 "/home/xb/project/ucx/src/ucs/.libs/ucx/libuct_ib.so.0"


定义结构和初始化:
static struct {
    ucs_init_once_t  init;
    char             module_ext[NAME_MAX];
    unsigned         srchpath_cnt;
    char             *srch_path[UCS_MODULE_SRCH_PATH_MAX];
} ucs_module_loader_state = {
    .init         = UCS_INIT_ONCE_INITIALIZER,
    .module_ext   = ".so", /* default extension */
    .srchpath_cnt = 0,
    .srch_path    = { NULL, NULL}
};


void UCS_F_CTOR ucs_init()
  ucs_modules_load
    UCS_MODULE_FRAMEWORK_LOAD(ucs, UCS_MODULE_LOAD_FLAG_GLOBAL)

xtor构造器(main前执行):
#define UCS_F_CTOR __attribute__((constructor))

顺序:
void UCS_F_CTOR ucm_init()
void UCS_F_CTOR ucs_init()
void UCS_F_CTOR uct_init()
void UCS_F_CTOR uct_ib_init()
UCS_F_CTOR void uct_rdmacm_init(void)

重命名后的构造器: UCS_STATIC_INIT
UCT_COMPONENT_REGISTER 注册组件



void UCS_F_CTOR ucm_init()
  ucm_init_log() -> ucm_log_hostname 获取主机名
  ucm_init_malloc_hook() -> ucs_recursive_spinlock_init -> 初始化可重入锁

void UCS_F_CTOR ucs_init()
  ucs_check_cpu_flags -> 检查cpu特性
  ucs_log_early_init -> 初始化日志,进程ID等
  ucs_global_opts_init -> 初始化全局配置选项, 获取配置文件路径, 填充配置文件等, 添加全局vfs节点(ucs/global_opts), vfs日志级别等
  ucs_init_ucm_opts -> 添加ucm全局配置表(内存对齐16, 日志级别为WARN等), 填充配置文件(包含环境变量,前缀为UCX_), 初始化ucs库(kh的hash表初始化, map初始化), 打开动态库: /home/xb/project/ucx/src/ucm/.libs/libucm.so.0, 为 aarch64 实现了 CUDA bistro 挂钩（以在此平台上启用内存缓存）
  ucs_memtype_cache_global_init -> 互斥锁初始化
  ucs_cpu_init -> 优化版本的memcpy, ucs_cpu_builtin_memcpy, 获取CPU提供者(ucs_cpu_vendor)
  ucs_log_init
  ucs_stats_init
  ucs_memtrack_init
  ucs_debug_init
  ucs_profile_init
  ucs_async_global_init
  ucs_numa_init
  ucs_topo_init
  ucs_rand_seed_init
  ucs_modules_load


ucs全局配置选项:
ucm_global_config_t ucm_global_opts = {
    .log_level                  = UCS_LOG_LEVEL_WARN,
    .enable_events              = 1,
    .mmap_hook_mode             = UCM_DEFAULT_HOOK_MODE,
    .enable_malloc_hooks        = 1,
    .enable_malloc_reloc        = 0,
    .cuda_hook_modes            =
#if UCM_BISTRO_HOOKS
                                  UCS_BIT(UCM_MMAP_HOOK_BISTRO) |
#endif
                                  UCS_BIT(UCM_MMAP_HOOK_RELOC),
    .enable_dynamic_mmap_thresh = 1,
    .alloc_alignment            = 16,
    .dlopen_process_rpath       = 1,
    .bistro_force_far_jump      = 0,
};



UCM：修复由 ucp_set_event_handler() 引起的堆损坏
修复安装时测试 mmap 事件的 sbrk() 与程序中任何其他线程的 brk/sbrk() 之间的竞争，作为正常堆操作的一部分。 这种竞争会导致堆损坏和程序中止/段错误。 一般来说，我们不应该直接调用brk/sbrk()。修复方法：
1. 在库初始化期间初始化 bistro 挂钩。 这可以确保没有其他线程会读取错误的机器指令。
2. 仅当事件测试来自独占上下文 (1) 时，才从事件测试中调用 brk/sbrk()。 对于非独占情况，仅使用无效参数进行虚拟调用，这不应对其他线程产生副作用。
3. 为 brk() 创建单独的事件，以避免在实际调用 brk() 时模拟 sbrk() 事件。
4. 修复 brk() 系统调用以返回完整的 64 位值
void ucm_mmap_init() -> 
  ucm_prevent_dl_unload
  ucm_mmap_install
    ucm_mmap_events_to_native_events
    ucm_mmap_test_events_nolock
    ucs_mmap_install_reloc
    ucm_mmap_test_events_nolock
    ucm_bistro_patch -> bistro hooks for cuda
      ucm_bistro_create_restore_point
      return ucm_bistro_apply_patch_atomic(func_ptr, patch, patch_len);



cpu提供商:
typedef enum ucs_cpu_vendor {
    UCS_CPU_VENDOR_UNKNOWN,
    UCS_CPU_VENDOR_INTEL,
    UCS_CPU_VENDOR_AMD,
    UCS_CPU_VENDOR_GENERIC_ARM,
    UCS_CPU_VENDOR_GENERIC_PPC,
    UCS_CPU_VENDOR_FUJITSU_ARM,
    UCS_CPU_VENDOR_ZHAOXIN,
    UCS_CPU_VENDOR_GENERIC_RV64G,
    UCS_CPU_VENDOR_LAST
} ucs_cpu_vendor_t;


CPU缓存类型
/* CPU cache types */
typedef enum ucs_cpu_cache_type {
    UCS_CPU_CACHE_L1d, /**< L1 data cache */          数据缓存
    UCS_CPU_CACHE_L1i, /**< L1 instruction cache */   指令缓存
    UCS_CPU_CACHE_L2,  /**< L2 cache */
    UCS_CPU_CACHE_L3,  /**< L3 cache */
    UCS_CPU_CACHE_LAST
} ucs_cpu_cache_type_t;
struct { /* sysfs entries for system cache sizes */
    int         level;
    const char *type;
} const ucs_cpu_cache_sysfs_name[] = {
    [UCS_CPU_CACHE_L1d] = {.level = 1, .type = "Data"},
    [UCS_CPU_CACHE_L1i] = {.level = 1, .type = "Instruction"},
    [UCS_CPU_CACHE_L2]  = {.level = 2, .type = "Unified"},
    [UCS_CPU_CACHE_L3]  = {.level = 3, .type = "Unified"}
};


src/ucs/arch/cpu.c
static void ucs_sysfs_get_cache_size() -> 获取缓存大小
double ucs_cpu_get_memcpy_bw() -> 获取内存带宽

带宽, k, m, g, t, p
#define UCS_KBYTE    (1ull << 10)
#define UCS_MBYTE    (1ull << 20)
#define UCS_GBYTE    (1ull << 30)
#define UCS_TBYTE    (1ull << 40)
#define UCS_PBYTE    (1ull << 50)

